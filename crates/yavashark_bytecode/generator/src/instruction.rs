use std::env::var;
use quote::quote;
use syn::{Field, FieldMutability, Fields, FieldsUnnamed, Variant, Visibility};
use syn::punctuated::Punctuated;
use crate::set;


#[derive(Debug, Clone, Copy)]
enum ArgumentType {
    Variable,
    Reg,
    Acc,
    Stack,
    Const,
}

impl ArgumentType {
    const NUM_TYPES: usize = 5;
}


#[derive(Debug, Clone, Copy)]
enum ReturnType {
    Variable,
    Reg,
    Acc,
    Stack,
}

impl ReturnType {
    const NUM_TYPES: usize = 4;
}

#[derive(Debug, Clone)]
struct InstructionVariant {
    name: String,
    inputs: Vec<ArgumentType>,
    output: Option<ReturnType>,
}


pub fn generate_instruction_enum() {
    let instructions = set::instructions();


    let mut output = quote! {
        // This file is automatically @generated by yavashark/generator.
        // It is not intended for manual editing.
    };


    let mut variants = Vec::new();

    for inst in instructions {
        let fields = if inst.inputs.is_empty() {
            Fields::Unit
        } else {
            
            
            let iter = inst.inputs.iter().map(|input| {
                Field {
                    attrs: Vec::new(),
                    vis: Visibility::Inherited,
                    mutability: FieldMutability::None,
                    ident: None,
                    colon_token: None,
                    ty: input.to_syn_crate(),
                }
            });
            
            Fields::Unnamed(FieldsUnnamed {
                paren_token: Default::default(),
                unnamed: Punctuated::from_iter(iter)
            })
        };
        
        variants.push(Variant {
            attrs: Vec::new(),
            ident: syn::Ident::new(&inst.name, proc_macro2::Span::call_site()),
            fields,
            discriminant: None,
        })
    }
    
    output.extend(quote! {
        #[derive(Debug, Clone, Copy)]
        pub enum Instruction {
            #(#variants),*
        }
    });





    println!("{:#?}", output);
}