use quote::quote;
use crate::parse;


#[derive(Debug, Clone, Copy)]
enum ArgumentType {
    Variable,
    Reg,
    Acc,
    Stack,
    Const,
}

impl ArgumentType {
    const NUM_TYPES: usize = 5;
}


#[derive(Debug, Clone, Copy)]
enum ReturnType {
    Variable,
    Reg,
    Acc,
    Stack,
}

impl ReturnType {
    const NUM_TYPES: usize = 4;
}

#[derive(Debug, Clone)]
struct InstructionVariant {
    name: String,
    inputs: Vec<ArgumentType>,
    output: Option<ReturnType>,
}


pub fn generate_instruction_enum() {
    let instructions = parse::instruction_def();


    let mut output = quote! {
        // This file is automatically @generated by yavashark/generator.
        // It is not intended for manual editing.
    };


    let mut variants = Vec::new();

    for inst in instructions {
        let mut instruction_variants = Vec::with_capacity(inst.num_instructions());

        instruction_variants.push(InstructionVariant {
            name: inst.name.clone(),
            inputs: Vec::new(),
            output: None,
        });
        

        


        for input in inst.inputs {
            repeat_vec(&mut instruction_variants, ArgumentType::NUM_TYPES);


        }




        // variants.push(generate_variant(&inst.name, ));
    }





    println!("{}", output);
}


fn repeat_vec<T: Clone>(vec: &mut Vec<T>, times: usize) {
    let len = vec.len();
    vec.reserve(len * times);

    for _ in 0..times {
        vec.extend_from_within(0..len);
    }
}