use crate::{parse, set};
use quote::quote;
use syn::punctuated::Punctuated;
use syn::{Field, FieldMutability, Fields, FieldsUnnamed, Variant, Visibility};

pub fn generate_instruction_enum() {
    let instructions = set::instructions();

    let mut variants_all = Vec::new();

    for inst in instructions {
        let fields = if inst.inputs.is_empty() && inst.output.is_none() {
            Fields::Unit
        } else {
            let iter = inst.inputs.iter().map(|input| Field {
                attrs: Vec::new(),
                vis: Visibility::Inherited,
                mutability: FieldMutability::None,
                ident: None,
                colon_token: None,
                ty: input.to_syn(),
            });

            let iter = iter.chain(inst.output.iter().map(|output| Field {
                attrs: Vec::new(),
                vis: Visibility::Inherited,
                mutability: FieldMutability::None,
                ident: None,
                colon_token: None,
                ty: output.to_syn(),
            }));

            Fields::Unnamed(FieldsUnnamed {
                paren_token: Default::default(),
                unnamed: Punctuated::from_iter(iter),
            })
        };

        variants_all.push(Variant {
            attrs: Vec::new(),
            ident: syn::Ident::new(&inst.name, proc_macro2::Span::call_site()),
            fields,
            discriminant: None,
        })
    }

    let defs = parse::instruction_def();

    let mut variants = Vec::new();

    for defs in defs {
        let fields = if defs.inputs.is_empty() && defs.output.is_none() {
            Fields::Unit
        } else {
            let iter = defs.inputs.iter().map(|input| Field {
                attrs: Vec::new(),
                vis: Visibility::Inherited,
                mutability: FieldMutability::None,
                ident: None,
                colon_token: None,
                ty: input.to_syn_val(),
            });

            let iter = iter.chain(defs.output.iter().map(|output| Field {
                attrs: Vec::new(),
                vis: Visibility::Inherited,
                mutability: FieldMutability::None,
                ident: None,
                colon_token: None,
                ty: output.to_syn_out_val(),
            }));

            Fields::Unnamed(FieldsUnnamed {
                paren_token: Default::default(),
                unnamed: Punctuated::from_iter(iter),
            })
        };

        variants.push(Variant {
            attrs: Vec::new(),
            ident: syn::Ident::new(&defs.name, proc_macro2::Span::call_site()),
            fields,
            discriminant: None,
        })
    }

    let output = quote! {
        #[cfg(not(feature = "simple_bytecode"))]
        #[derive(Debug, Clone, Copy, PartialEq)]
        pub enum Instruction {
            #(#variants_all),*
        }

        #[cfg(feature = "simple_bytecode")]
        #[derive(Debug, Clone, Copy, PartialEq)]
        pub enum Instruction {
            #(#variants),*
        }
    };

    let file = syn::parse_file(&output.to_string()).unwrap();

    let header = r#"// This file is automatically @generated by yavashark/generator.
// It is not intended for manual editing.
#![allow(warnings)]
#![allow(unknown_lints)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use crate::data::{Acc, ConstIdx, Reg, Stack, VarName, Label, ControlIdx, F32, I32, U32, Boolean, Null, Undefined, DataType, OutputDataType};
use crate::{JmpOffset, JmpAddr}; 



"#;

    let code = prettyplease::unparse(&file);

    let out = format!("{}{}", header, code);

    std::fs::write("crates/yavashark_bytecode/src/instructions.rs", out).unwrap();
}
