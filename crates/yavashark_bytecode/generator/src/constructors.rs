use crate::parse::Type;
use crate::set::{ArgumentType, ReturnType};
use crate::{parse, set};
use proc_macro2::{Ident, TokenStream};
use quote::quote;

pub fn generate_constructors() {
    let defs = parse::instruction_def();

    let mut constructors_all = Vec::new();

    for def in defs {
        let fn_name = Ident::new(&set::get_class(&def.name), proc_macro2::Span::call_site());

        let args = def.inputs.iter().enumerate().map(|(i, input)| {
            let id = Ident::new(&format!("arg{}", i), proc_macro2::Span::call_site());
            let ty = input.to_syn();

            (quote! { #id: #ty }, id)
        });

        let args = args
            .chain(def.output.iter().map(|output| {
                let id = Ident::new("output", proc_macro2::Span::call_site());
                let ty = output.to_syn_out();

                (quote! { #id: #ty }, id)
            }))
            .collect::<Vec<_>>();

        let fn_args = args.iter().map(|(arg, _)| arg);
        let call_args = args.iter().map(|(_, id)| id.clone()).collect::<Vec<_>>();

        let matcher = gen_match(
            &def.name,
            &mut Vec::new(),
            &def.inputs,
            def.output.as_ref(),
            &call_args,
        );

        constructors_all.push(quote! {
            #[must_use]
            pub fn #fn_name(#(#fn_args),*) -> Self {
                #matcher
            }
        })
    }

    let mut constructors = Vec::new();

    for def in defs {
        let fn_name = Ident::new(&set::get_class(&def.name), proc_macro2::Span::call_site());

        let args = def.inputs.iter().enumerate().map(|(i, input)| {
            let id = Ident::new(&format!("arg{}", i), proc_macro2::Span::call_site());
            let ty = input.to_syn();

            let tok = match input {
                Type::Data => quote! { #id.data_type() },
                _ => quote! { #id },
            };

            (quote! { #id: #ty }, tok)
        });

        let args = args
            .chain(def.output.iter().map(|output| {
                let id = Ident::new("output", proc_macro2::Span::call_site());
                let ty = output.to_syn_out();

                let tok = match output {
                    Type::Data => quote! { #id.data_type() },
                    _ => quote! { #id },
                };

                (quote! { #id: #ty }, tok)
            }))
            .collect::<Vec<_>>();

        let fn_args = args.iter().map(|(arg, _)| arg);
        let call_args = args.iter().map(|(_, id)| id).collect::<Vec<_>>();

        let variant = Ident::new(&def.name, proc_macro2::Span::call_site());

        if call_args.is_empty() {
            constructors.push(quote! {
                #[must_use]
                pub fn #fn_name(#(#fn_args),*) -> Self {
                    Self::#variant
                }
            })
        } else {
            constructors.push(quote! {
                #[must_use]
                pub fn #fn_name(#(#fn_args),*) -> Self {
                    Self::#variant(#(#call_args),*)
                }
            })
        }
    }

    let output = quote! {
        #[cfg(not(feature = "simple_bytecode"))]
        impl Instruction {
            #(#constructors_all)*
        }

        #[cfg(feature = "simple_bytecode")]
        impl Instruction {
            #(#constructors)*
        }
    };

    let header = r#"// This file is automatically @generated by yavashark/generator.
// It is not intended for manual editing.
#![allow(clippy::missing_const_for_fn, clippy::cognitive_complexity)]
#![allow(unknown_lints)]
#![allow(warnings)]
#![cfg_attr(rustfmt, rustfmt_skip)]


use crate::data::{Data, DataType, OutputData, OutputDataType, Label, ControlIdx, VarName};
use crate::{JmpOffset, JmpAddr}; 
use crate::instructions::Instruction; 


"#;

    let file = syn::parse_file(&output.to_string()).unwrap();

    let out = prettyplease::unparse(&file);

    let out = format!("{}{}", header, out);

    std::fs::write("crates/yavashark_bytecode/src/constructor.rs", out).unwrap();
}

fn gen_match(
    name: &str,
    prev: &mut Vec<ArgumentType>,
    input: &[Type],
    out: Option<&Type>,
    args: &[Ident],
) -> TokenStream {
    if input.is_empty() && out.is_none() {
        let name = Ident::new(name, proc_macro2::Span::call_site());

        return quote! {
            Self::#name
        };
    }

    if !input.is_empty() {
        gen_match_input(name, prev, input, out, args)
    } else {
        gen_match_output(name, prev, out.unwrap(), args)
    }
}

fn gen_match_input(
    name: &str,
    prev: &mut Vec<ArgumentType>,
    input: &[Type],
    out: Option<&Type>,
    args: &[Ident],
) -> TokenStream {
    let (first, input) = input.split_first().unwrap();

    let is_last = input.is_empty() && out.is_none();

    if is_last {
        return gen_last(name, prev, first, args);
    }

    if first != &Type::Data {
        prev.push(ArgumentType::Other("Other".to_string()));
        let out = gen_match(name, prev, input, out, args);
        prev.pop();

        return out;
    }

    let arg_name = Ident::new(
        &format!("arg{}", prev.len()),
        proc_macro2::Span::call_site(),
    );

    let acc = {
        prev.push(ArgumentType::Acc);
        let out = gen_match(name, prev, input, out, args);
        prev.pop();

        out
    };

    let const_idx = {
        prev.push(ArgumentType::Const);
        let out = gen_match(name, prev, input, out, args);
        prev.pop();

        out
    };

    let reg = {
        prev.push(ArgumentType::Reg);
        let out = gen_match(name, prev, input, out, args);
        prev.pop();

        out
    };

    let stack = {
        prev.push(ArgumentType::Stack);
        let out = gen_match(name, prev, input, out, args);
        prev.pop();

        out
    };

    let var = {
        prev.push(ArgumentType::Variable);
        let out = gen_match(name, prev, input, out, args);
        prev.pop();

        out
    };

    let f32 = {
        prev.push(ArgumentType::F32);
        let out = gen_match(name, prev, input, out, args);
        prev.pop();

        out
    };

    let i32 = {
        prev.push(ArgumentType::I32);
        let out = gen_match(name, prev, input, out, args);
        prev.pop();

        out
    };

    let u32 = {
        prev.push(ArgumentType::U32);
        let out = gen_match(name, prev, input, out, args);
        prev.pop();

        out
    };

    let boolean = {
        prev.push(ArgumentType::Boolean);
        let out = gen_match(name, prev, input, out, args);
        prev.pop();

        out
    };

    let null = {
        prev.push(ArgumentType::Null);
        let out = gen_match(name, prev, input, out, args);
        prev.pop();

        out
    };

    let undefined = {
        prev.push(ArgumentType::Undefined);
        let out = gen_match(name, prev, input, out, args);
        prev.pop();

        out
    };

    quote! {
        match #arg_name.data_type() {
            DataType::Acc(#arg_name) => #acc,
            DataType::Const(#arg_name) => #const_idx,
            DataType::Reg(#arg_name) => #reg,
            DataType::Stack(#arg_name) => #stack,
            DataType::Var(#arg_name) => #var,
            DataType::F32(#arg_name) => #f32,
            DataType::I32(#arg_name) => #i32,
            DataType::U32(#arg_name) => #u32,
            DataType::Boolean(#arg_name) => #boolean,
            DataType::Null(#arg_name) => #null,
            DataType::Undefined(#arg_name) => #undefined,
        }
    }
}

fn gen_last(name: &str, prev: &mut Vec<ArgumentType>, last: &Type, args: &[Ident]) -> TokenStream {
    if last != &Type::Data {
        let out = get_enum_variant(name, prev);

        return quote! {
            Self::#out(#(#args),*)
        };
    }

    let arg_name = Ident::new(
        &format!("arg{}", prev.len()),
        proc_macro2::Span::call_site(),
    );

    let acc = {
        prev.push(ArgumentType::Acc);
        let out = get_enum_variant(name, prev);
        prev.pop();

        out
    };

    let const_idx = {
        prev.push(ArgumentType::Const);
        let out = get_enum_variant(name, prev);
        prev.pop();

        out
    };

    let reg = {
        prev.push(ArgumentType::Reg);
        let out = get_enum_variant(name, prev);
        prev.pop();

        out
    };

    let stack = {
        prev.push(ArgumentType::Stack);
        let out = get_enum_variant(name, prev);
        prev.pop();

        out
    };

    let var = {
        prev.push(ArgumentType::Variable);
        let out = get_enum_variant(name, prev);
        prev.pop();

        out
    };

    let f32 = {
        prev.push(ArgumentType::F32);
        let out = get_enum_variant(name, prev);
        prev.pop();

        out
    };

    let i32 = {
        prev.push(ArgumentType::I32);
        let out = get_enum_variant(name, prev);
        prev.pop();

        out
    };

    let u32 = {
        prev.push(ArgumentType::U32);
        let out = get_enum_variant(name, prev);
        prev.pop();

        out
    };

    let boolean = {
        prev.push(ArgumentType::Boolean);
        let out = get_enum_variant(name, prev);
        prev.pop();

        out
    };

    let null = {
        prev.push(ArgumentType::Null);
        let out = get_enum_variant(name, prev);
        prev.pop();

        out
    };

    let undefined = {
        prev.push(ArgumentType::Undefined);
        let out = get_enum_variant(name, prev);
        prev.pop();

        out
    };

    quote! {
        match #arg_name.data_type() {
            DataType::Acc(#arg_name) => Self::#acc(#(#args),*),
            DataType::Const(#arg_name) => Self::#const_idx(#(#args),*),
            DataType::Reg(#arg_name) => Self::#reg(#(#args),*),
            DataType::Stack(#arg_name) => Self::#stack(#(#args),*),
            DataType::Var(#arg_name) => Self::#var(#(#args),*),
            DataType::F32(#arg_name) => Self::#f32(#(#args),*),
            DataType::I32(#arg_name) => Self::#i32(#(#args),*),
            DataType::U32(#arg_name) => Self::#u32(#(#args),*),
            DataType::Boolean(#arg_name) => Self::#boolean(#(#args),*),
            DataType::Null(#arg_name) => Self::#null(#(#args),*),
            DataType::Undefined(#arg_name) => Self::#undefined(#(#args),*),
        }
    }
}

fn gen_match_output(
    name: &str,
    prev: &[ArgumentType],
    _last: &Type,
    args: &[Ident],
) -> TokenStream {
    let acc = get_enum_variant_out(name, prev, ReturnType::Acc);
    let reg = get_enum_variant_out(name, prev, ReturnType::Reg);
    let stack = get_enum_variant_out(name, prev, ReturnType::Stack);
    let var = get_enum_variant_out(name, prev, ReturnType::Variable);

    quote! {
        match output.data_type() {
            OutputDataType::Acc(output) => Self::#acc(#(#args),*),
            OutputDataType::Reg(output) => Self::#reg(#(#args),*),
            OutputDataType::Stack(output) => Self::#stack(#(#args),*),
            OutputDataType::Var(output) => Self::#var(#(#args),*),
        }
    }
}

fn get_enum_variant(name: &str, prev: &[ArgumentType]) -> Ident {
    let mut out = name.to_owned();

    for arg in prev {
        match arg {
            ArgumentType::Acc => out.push_str("Acc"),
            ArgumentType::Const => out.push_str("Const"),
            ArgumentType::Reg => out.push_str("Reg"),
            ArgumentType::Stack => out.push_str("Stack"),
            ArgumentType::Variable => out.push_str("Var"),
            ArgumentType::F32 => out.push_str("F32"),
            ArgumentType::I32 => out.push_str("I32"),
            ArgumentType::U32 => out.push_str("U32"),
            ArgumentType::Boolean => out.push_str("Bool"),
            ArgumentType::Null => out.push_str("Null"),
            ArgumentType::Undefined => out.push_str("Undefined"),
            ArgumentType::Other(_) => {}
        }
    }

    Ident::new(&out, proc_macro2::Span::call_site())
}

fn get_enum_variant_out(name: &str, prev: &[ArgumentType], output: ReturnType) -> Ident {
    let mut out = name.to_owned();

    for arg in prev {
        match arg {
            ArgumentType::Acc => out.push_str("Acc"),
            ArgumentType::Const => out.push_str("Const"),
            ArgumentType::Reg => out.push_str("Reg"),
            ArgumentType::Stack => out.push_str("Stack"),
            ArgumentType::Variable => out.push_str("Var"),
            ArgumentType::F32 => out.push_str("F32"),
            ArgumentType::I32 => out.push_str("I32"),
            ArgumentType::U32 => out.push_str("U32"),
            ArgumentType::Boolean => out.push_str("Bool"),
            ArgumentType::Null => out.push_str("Null"),
            ArgumentType::Undefined => out.push_str("Undefined"),
            ArgumentType::Other(_) => {}
        }
    }

    out.push_str("To");

    match output {
        ReturnType::Variable => out.push_str("Var"),
        ReturnType::Reg => out.push_str("Reg"),
        ReturnType::Acc => out.push_str("Acc"),
        ReturnType::Stack => out.push_str("Stack"),
        ReturnType::Other(_) => {}
    }

    Ident::new(&out, proc_macro2::Span::call_site())
}
