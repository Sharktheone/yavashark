use convert_case::Casing;
use crate::set;
use proc_macro2::{Ident, TokenStream};
use quote::quote;

pub fn generate_execute() {
    let instructions = set::instructions();

    let mut variants = Vec::new();

    for inst in instructions {
        let mut args = Vec::with_capacity(inst.inputs.len());

        for input in 0..inst.inputs.len() {
            let id = Ident::new(&format!("arg{}", input), proc_macro2::Span::call_site());

            args.push(quote! { #id });
        }

        let name = Ident::new(&inst.name, proc_macro2::Span::call_site());
        let execute_fn = Ident::new(&inst.class, proc_macro2::Span::call_site());
        
        if inst.output.is_some() {
            args.push(quote! { output });
        }
        
        let match_args = if args.is_empty() {
            TokenStream::new()
        } else {
            quote! { (#(#args),*) }
        };
        
        args.push(quote! { vm });

        variants.push(quote! {
            Self::#name #match_args => instruction::#execute_fn(#(#args),*),
        });
    }

    let output = quote! {
        impl Execute for Instruction {
            fn execute(self, vm: &mut impl VM) -> ControlResult {
                match self {
                    #(#variants)*
                }
            }
        }
    };

    let header = r#"// This file is automatically @generated by yavashark/generator.
// It is not intended for manual editing.

use crate::instruction;
use crate::VM;
use yavashark_bytecode::instructions::Instruction;
use yavashark_env::ControlResult;


pub trait Execute {
    fn execute(self, vm: &mut impl VM) -> ControlResult;
}



"#;

    let file = syn::File {
        shebang: None,
        attrs: Vec::new(),
        items: vec![
            syn::parse2(output).unwrap(),
        ],
    };
    
    let file = prettyplease::unparse(&file);

    let out = format!("{}{}", header, file);

    std::fs::write("crates/yavashark_vm/src/execute.rs", out).unwrap();
}
