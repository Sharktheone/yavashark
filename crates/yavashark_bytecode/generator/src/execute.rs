use crate::set::get_class;
use crate::{parse, set};
use proc_macro2::{Ident, TokenStream};
use quote::quote;

pub fn generate_execute() {
    let instructions = set::instructions();

    let mut variants_all = Vec::new();

    for inst in instructions {
        let mut args = Vec::with_capacity(inst.inputs.len());

        for input in 0..inst.inputs.len() {
            let id = Ident::new(&format!("arg{}", input), proc_macro2::Span::call_site());

            args.push(quote! { #id });
        }

        let name = Ident::new(&inst.name, proc_macro2::Span::call_site());
        let execute_fn = Ident::new(&inst.class, proc_macro2::Span::call_site());

        if inst.output.is_some() {
            args.push(quote! { output });
        }

        let match_args = if args.is_empty() {
            TokenStream::new()
        } else {
            quote! { (#(#args),*) }
        };

        args.push(quote! { vm });

        variants_all.push(quote! {
            Self::#name #match_args => instruction::#execute_fn(#(#args),*)?,
        });
    }

    let defs = parse::instruction_def();

    let mut variants = Vec::new();

    for def in defs {
        let mut args = Vec::with_capacity(def.inputs.len());

        for input in 0..def.inputs.len() {
            let id = Ident::new(&format!("arg{}", input), proc_macro2::Span::call_site());

            args.push(quote! { #id });
        }

        let name = Ident::new(&def.name, proc_macro2::Span::call_site());
        let execute_fn = Ident::new(&get_class(&def.name), proc_macro2::Span::call_site());

        if def.output.is_some() {
            args.push(quote! { output });
        }

        let match_args = if args.is_empty() {
            TokenStream::new()
        } else {
            quote! { (#(#args),*) }
        };

        args.push(quote! { vm });

        variants.push(quote! {
            Self::#name #match_args => instruction::#execute_fn(#(#args),*)?,
        });
    }

    let output = quote! {
        #[cfg(not(feature = "simple_bytecode"))]
        impl Execute for Instruction {
            fn execute(self, vm: &mut impl VM) -> ControlResult {
                match self {
                    #(#variants_all)*
                }

                Ok(())
            }
        }


        #[cfg(feature = "simple_bytecode")]
        impl Execute for Instruction {
            fn execute(self, vm: &mut impl VM) -> ControlResult {
                match self {
                    #(#variants)*
                }

                Ok(())
            }
        }
    };

    let header = r#"// This file is automatically @generated by yavashark/generator.
// It is not intended for manual editing.
#![allow(unknown_lints)]
#![allow(warnings)] 
#![cfg_attr(rustfmt, rustfmt_skip)]

use crate::instruction;
use crate::VM;
use yavashark_bytecode::instructions::Instruction;
use yavashark_env::ControlResult;


pub trait Execute {
    fn execute(self, vm: &mut impl VM) -> ControlResult;
}



"#;

    let file = syn::parse_file(&output.to_string()).unwrap();

    let file = prettyplease::unparse(&file);

    let out = format!("{}{}", header, file);

    std::fs::write("crates/yavashark_vm/src/execute.rs", out).unwrap();
}
