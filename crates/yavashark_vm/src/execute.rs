// This file is automatically @generated by yavashark/generator.
// It is not intended for manual editing.
#![allow(unknown_lints)]
#![allow(warnings)] 
#![cfg_attr(rustfmt, rustfmt_skip)]

use crate::instruction;
use crate::VM;
use yavashark_bytecode::instructions::Instruction;
use yavashark_env::ControlResult;


pub trait Execute {
    fn execute(self, vm: &mut impl VM) -> ControlResult;
}



#[cfg(not(feature = "simple_bytecode"))]
impl Execute for Instruction {
    fn execute(self, vm: &mut impl VM) -> ControlResult {
        match self {
            Self::AddVarVarToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegVarToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccVarToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackVarToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstVarToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32VarToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32VarToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32VarToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolVarToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullVarToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedVarToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarRegToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegRegToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccRegToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackRegToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstRegToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32RegToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32RegToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32RegToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolRegToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullRegToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedRegToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarAccToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegAccToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccAccToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackAccToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstAccToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32AccToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32AccToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32AccToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolAccToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullAccToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedAccToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarStackToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegStackToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccStackToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackStackToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstStackToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32StackToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32StackToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32StackToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolStackToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullStackToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedStackToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarConstToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegConstToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccConstToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackConstToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstConstToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32ConstToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32ConstToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32ConstToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolConstToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullConstToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedConstToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarF32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegF32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccF32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackF32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstF32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32F32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32F32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32F32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolF32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullF32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarI32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegI32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccI32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackI32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstI32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32I32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32I32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32I32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolI32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullI32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarU32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegU32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccU32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackU32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstU32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32U32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32U32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32U32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolU32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullU32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarBoolToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegBoolToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccBoolToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackBoolToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstBoolToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32BoolToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32BoolToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32BoolToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolBoolToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullBoolToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarNullToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegNullToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccNullToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackNullToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstNullToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32NullToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32NullToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32NullToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolNullToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullNullToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedNullToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarUndefinedToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegUndefinedToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccUndefinedToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackUndefinedToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstUndefinedToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32UndefinedToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32UndefinedToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32UndefinedToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullUndefinedToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarVarToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegVarToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccVarToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackVarToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstVarToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32VarToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32VarToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32VarToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolVarToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullVarToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedVarToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarRegToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegRegToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccRegToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackRegToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstRegToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32RegToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32RegToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32RegToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolRegToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullRegToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedRegToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarAccToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegAccToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccAccToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackAccToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstAccToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32AccToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32AccToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32AccToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolAccToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullAccToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedAccToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarStackToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegStackToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccStackToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackStackToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstStackToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32StackToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32StackToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32StackToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolStackToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullStackToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedStackToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarConstToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegConstToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccConstToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackConstToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstConstToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32ConstToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32ConstToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32ConstToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolConstToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullConstToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedConstToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarF32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegF32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccF32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackF32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstF32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32F32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32F32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32F32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolF32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullF32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarI32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegI32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccI32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackI32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstI32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32I32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32I32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32I32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolI32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullI32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarU32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegU32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccU32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackU32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstU32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32U32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32U32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32U32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolU32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullU32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarBoolToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegBoolToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccBoolToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackBoolToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstBoolToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32BoolToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32BoolToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32BoolToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolBoolToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullBoolToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarNullToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegNullToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccNullToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackNullToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstNullToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32NullToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32NullToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32NullToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolNullToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullNullToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedNullToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarUndefinedToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegUndefinedToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccUndefinedToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackUndefinedToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstUndefinedToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32UndefinedToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32UndefinedToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32UndefinedToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullUndefinedToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarVarToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegVarToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccVarToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackVarToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstVarToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32VarToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32VarToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32VarToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolVarToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullVarToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarRegToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegRegToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccRegToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackRegToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstRegToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32RegToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32RegToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32RegToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolRegToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullRegToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarAccToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegAccToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccAccToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackAccToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstAccToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32AccToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32AccToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32AccToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolAccToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullAccToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarStackToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegStackToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccStackToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackStackToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstStackToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32StackToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32StackToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32StackToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolStackToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullStackToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarConstToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegConstToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccConstToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackConstToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstConstToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32ConstToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32ConstToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32ConstToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolConstToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullConstToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarF32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegF32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccF32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackF32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstF32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32F32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32F32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32F32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolF32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullF32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarI32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegI32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccI32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackI32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstI32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32I32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32I32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32I32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolI32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullI32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarU32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegU32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccU32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackU32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstU32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32U32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32U32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32U32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolU32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullU32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarBoolToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegBoolToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccBoolToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackBoolToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstBoolToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32BoolToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32BoolToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32BoolToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolBoolToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullBoolToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarNullToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegNullToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccNullToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackNullToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstNullToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32NullToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32NullToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32NullToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolNullToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullNullToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarVarToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegVarToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccVarToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackVarToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstVarToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32VarToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32VarToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32VarToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolVarToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullVarToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedVarToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarRegToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegRegToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccRegToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackRegToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstRegToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32RegToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32RegToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32RegToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolRegToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullRegToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedRegToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarAccToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegAccToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccAccToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackAccToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstAccToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32AccToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32AccToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32AccToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolAccToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullAccToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedAccToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarStackToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegStackToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccStackToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackStackToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstStackToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32StackToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32StackToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32StackToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolStackToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullStackToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedStackToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarConstToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegConstToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccConstToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackConstToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstConstToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32ConstToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32ConstToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32ConstToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolConstToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullConstToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedConstToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarF32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegF32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccF32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackF32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstF32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32F32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32F32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32F32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolF32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullF32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarI32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegI32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccI32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackI32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstI32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32I32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32I32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32I32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolI32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullI32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarU32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegU32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccU32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackU32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstU32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32U32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32U32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32U32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolU32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullU32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarBoolToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegBoolToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccBoolToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackBoolToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstBoolToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32BoolToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32BoolToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32BoolToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolBoolToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullBoolToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarNullToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegNullToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccNullToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackNullToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstNullToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32NullToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32NullToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32NullToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolNullToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullNullToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedNullToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddVarUndefinedToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddRegUndefinedToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddAccUndefinedToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddStackUndefinedToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddConstUndefinedToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddF32UndefinedToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddI32UndefinedToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddU32UndefinedToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddNullUndefinedToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::AddUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::add(arg0, arg1, output, vm)?
            }
            Self::SubVarVarToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegVarToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccVarToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackVarToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstVarToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32VarToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32VarToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32VarToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolVarToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullVarToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedVarToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarRegToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegRegToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccRegToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackRegToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstRegToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32RegToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32RegToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32RegToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolRegToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullRegToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedRegToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarAccToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegAccToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccAccToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackAccToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstAccToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32AccToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32AccToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32AccToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolAccToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullAccToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedAccToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarStackToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegStackToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccStackToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackStackToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstStackToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32StackToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32StackToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32StackToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolStackToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullStackToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedStackToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarConstToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegConstToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccConstToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackConstToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstConstToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32ConstToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32ConstToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32ConstToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolConstToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullConstToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedConstToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarF32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegF32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccF32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackF32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstF32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32F32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32F32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32F32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolF32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullF32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarI32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegI32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccI32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackI32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstI32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32I32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32I32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32I32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolI32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullI32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarU32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegU32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccU32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackU32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstU32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32U32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32U32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32U32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolU32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullU32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarBoolToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegBoolToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccBoolToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackBoolToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstBoolToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32BoolToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32BoolToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32BoolToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolBoolToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullBoolToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarNullToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegNullToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccNullToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackNullToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstNullToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32NullToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32NullToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32NullToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolNullToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullNullToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedNullToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarUndefinedToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegUndefinedToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccUndefinedToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackUndefinedToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstUndefinedToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32UndefinedToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32UndefinedToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32UndefinedToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullUndefinedToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarVarToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegVarToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccVarToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackVarToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstVarToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32VarToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32VarToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32VarToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolVarToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullVarToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedVarToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarRegToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegRegToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccRegToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackRegToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstRegToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32RegToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32RegToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32RegToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolRegToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullRegToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedRegToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarAccToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegAccToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccAccToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackAccToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstAccToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32AccToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32AccToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32AccToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolAccToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullAccToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedAccToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarStackToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegStackToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccStackToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackStackToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstStackToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32StackToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32StackToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32StackToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolStackToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullStackToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedStackToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarConstToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegConstToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccConstToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackConstToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstConstToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32ConstToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32ConstToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32ConstToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolConstToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullConstToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedConstToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarF32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegF32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccF32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackF32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstF32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32F32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32F32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32F32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolF32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullF32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarI32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegI32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccI32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackI32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstI32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32I32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32I32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32I32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolI32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullI32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarU32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegU32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccU32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackU32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstU32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32U32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32U32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32U32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolU32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullU32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarBoolToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegBoolToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccBoolToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackBoolToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstBoolToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32BoolToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32BoolToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32BoolToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolBoolToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullBoolToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarNullToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegNullToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccNullToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackNullToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstNullToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32NullToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32NullToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32NullToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolNullToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullNullToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedNullToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarUndefinedToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegUndefinedToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccUndefinedToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackUndefinedToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstUndefinedToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32UndefinedToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32UndefinedToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32UndefinedToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullUndefinedToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarVarToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegVarToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccVarToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackVarToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstVarToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32VarToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32VarToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32VarToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolVarToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullVarToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarRegToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegRegToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccRegToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackRegToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstRegToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32RegToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32RegToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32RegToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolRegToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullRegToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarAccToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegAccToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccAccToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackAccToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstAccToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32AccToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32AccToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32AccToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolAccToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullAccToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarStackToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegStackToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccStackToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackStackToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstStackToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32StackToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32StackToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32StackToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolStackToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullStackToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarConstToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegConstToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccConstToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackConstToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstConstToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32ConstToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32ConstToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32ConstToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolConstToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullConstToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarF32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegF32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccF32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackF32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstF32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32F32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32F32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32F32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolF32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullF32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarI32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegI32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccI32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackI32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstI32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32I32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32I32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32I32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolI32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullI32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarU32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegU32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccU32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackU32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstU32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32U32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32U32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32U32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolU32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullU32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarBoolToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegBoolToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccBoolToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackBoolToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstBoolToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32BoolToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32BoolToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32BoolToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolBoolToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullBoolToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarNullToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegNullToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccNullToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackNullToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstNullToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32NullToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32NullToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32NullToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolNullToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullNullToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarVarToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegVarToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccVarToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackVarToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstVarToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32VarToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32VarToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32VarToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolVarToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullVarToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedVarToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarRegToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegRegToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccRegToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackRegToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstRegToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32RegToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32RegToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32RegToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolRegToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullRegToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedRegToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarAccToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegAccToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccAccToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackAccToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstAccToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32AccToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32AccToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32AccToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolAccToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullAccToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedAccToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarStackToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegStackToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccStackToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackStackToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstStackToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32StackToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32StackToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32StackToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolStackToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullStackToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedStackToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarConstToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegConstToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccConstToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackConstToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstConstToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32ConstToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32ConstToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32ConstToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolConstToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullConstToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedConstToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarF32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegF32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccF32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackF32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstF32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32F32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32F32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32F32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolF32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullF32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarI32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegI32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccI32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackI32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstI32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32I32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32I32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32I32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolI32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullI32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarU32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegU32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccU32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackU32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstU32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32U32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32U32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32U32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolU32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullU32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarBoolToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegBoolToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccBoolToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackBoolToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstBoolToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32BoolToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32BoolToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32BoolToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolBoolToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullBoolToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarNullToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegNullToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccNullToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackNullToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstNullToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32NullToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32NullToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32NullToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolNullToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullNullToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedNullToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubVarUndefinedToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubRegUndefinedToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubAccUndefinedToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubStackUndefinedToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubConstUndefinedToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubF32UndefinedToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubI32UndefinedToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubU32UndefinedToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubNullUndefinedToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::SubUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::sub(arg0, arg1, output, vm)?
            }
            Self::MulVarVarToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegVarToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccVarToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackVarToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstVarToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32VarToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32VarToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32VarToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolVarToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullVarToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedVarToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarRegToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegRegToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccRegToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackRegToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstRegToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32RegToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32RegToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32RegToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolRegToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullRegToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedRegToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarAccToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegAccToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccAccToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackAccToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstAccToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32AccToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32AccToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32AccToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolAccToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullAccToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedAccToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarStackToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegStackToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccStackToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackStackToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstStackToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32StackToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32StackToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32StackToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolStackToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullStackToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedStackToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarConstToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegConstToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccConstToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackConstToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstConstToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32ConstToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32ConstToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32ConstToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolConstToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullConstToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedConstToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarF32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegF32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccF32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackF32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstF32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32F32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32F32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32F32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolF32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullF32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarI32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegI32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccI32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackI32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstI32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32I32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32I32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32I32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolI32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullI32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarU32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegU32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccU32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackU32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstU32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32U32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32U32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32U32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolU32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullU32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarBoolToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegBoolToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccBoolToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackBoolToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstBoolToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32BoolToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32BoolToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32BoolToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolBoolToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullBoolToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarNullToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegNullToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccNullToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackNullToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstNullToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32NullToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32NullToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32NullToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolNullToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullNullToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedNullToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarUndefinedToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegUndefinedToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccUndefinedToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackUndefinedToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstUndefinedToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32UndefinedToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32UndefinedToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32UndefinedToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullUndefinedToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarVarToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegVarToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccVarToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackVarToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstVarToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32VarToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32VarToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32VarToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolVarToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullVarToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedVarToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarRegToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegRegToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccRegToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackRegToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstRegToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32RegToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32RegToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32RegToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolRegToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullRegToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedRegToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarAccToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegAccToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccAccToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackAccToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstAccToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32AccToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32AccToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32AccToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolAccToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullAccToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedAccToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarStackToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegStackToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccStackToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackStackToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstStackToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32StackToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32StackToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32StackToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolStackToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullStackToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedStackToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarConstToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegConstToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccConstToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackConstToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstConstToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32ConstToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32ConstToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32ConstToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolConstToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullConstToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedConstToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarF32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegF32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccF32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackF32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstF32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32F32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32F32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32F32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolF32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullF32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarI32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegI32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccI32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackI32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstI32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32I32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32I32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32I32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolI32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullI32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarU32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegU32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccU32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackU32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstU32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32U32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32U32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32U32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolU32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullU32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarBoolToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegBoolToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccBoolToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackBoolToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstBoolToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32BoolToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32BoolToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32BoolToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolBoolToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullBoolToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarNullToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegNullToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccNullToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackNullToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstNullToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32NullToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32NullToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32NullToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolNullToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullNullToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedNullToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarUndefinedToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegUndefinedToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccUndefinedToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackUndefinedToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstUndefinedToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32UndefinedToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32UndefinedToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32UndefinedToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullUndefinedToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarVarToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegVarToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccVarToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackVarToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstVarToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32VarToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32VarToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32VarToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolVarToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullVarToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarRegToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegRegToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccRegToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackRegToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstRegToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32RegToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32RegToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32RegToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolRegToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullRegToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarAccToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegAccToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccAccToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackAccToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstAccToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32AccToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32AccToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32AccToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolAccToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullAccToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarStackToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegStackToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccStackToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackStackToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstStackToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32StackToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32StackToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32StackToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolStackToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullStackToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarConstToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegConstToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccConstToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackConstToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstConstToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32ConstToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32ConstToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32ConstToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolConstToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullConstToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarF32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegF32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccF32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackF32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstF32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32F32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32F32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32F32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolF32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullF32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarI32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegI32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccI32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackI32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstI32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32I32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32I32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32I32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolI32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullI32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarU32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegU32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccU32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackU32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstU32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32U32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32U32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32U32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolU32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullU32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarBoolToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegBoolToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccBoolToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackBoolToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstBoolToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32BoolToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32BoolToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32BoolToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolBoolToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullBoolToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarNullToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegNullToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccNullToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackNullToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstNullToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32NullToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32NullToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32NullToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolNullToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullNullToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarVarToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegVarToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccVarToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackVarToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstVarToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32VarToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32VarToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32VarToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolVarToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullVarToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedVarToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarRegToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegRegToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccRegToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackRegToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstRegToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32RegToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32RegToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32RegToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolRegToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullRegToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedRegToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarAccToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegAccToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccAccToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackAccToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstAccToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32AccToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32AccToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32AccToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolAccToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullAccToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedAccToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarStackToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegStackToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccStackToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackStackToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstStackToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32StackToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32StackToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32StackToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolStackToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullStackToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedStackToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarConstToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegConstToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccConstToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackConstToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstConstToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32ConstToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32ConstToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32ConstToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolConstToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullConstToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedConstToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarF32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegF32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccF32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackF32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstF32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32F32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32F32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32F32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolF32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullF32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarI32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegI32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccI32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackI32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstI32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32I32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32I32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32I32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolI32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullI32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarU32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegU32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccU32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackU32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstU32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32U32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32U32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32U32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolU32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullU32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarBoolToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegBoolToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccBoolToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackBoolToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstBoolToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32BoolToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32BoolToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32BoolToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolBoolToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullBoolToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarNullToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegNullToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccNullToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackNullToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstNullToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32NullToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32NullToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32NullToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolNullToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullNullToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedNullToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulVarUndefinedToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulRegUndefinedToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulAccUndefinedToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulStackUndefinedToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulConstUndefinedToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulF32UndefinedToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulI32UndefinedToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulU32UndefinedToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulNullUndefinedToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::MulUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::mul(arg0, arg1, output, vm)?
            }
            Self::DivVarVarToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegVarToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccVarToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackVarToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstVarToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32VarToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32VarToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32VarToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolVarToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullVarToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedVarToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarRegToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegRegToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccRegToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackRegToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstRegToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32RegToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32RegToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32RegToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolRegToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullRegToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedRegToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarAccToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegAccToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccAccToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackAccToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstAccToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32AccToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32AccToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32AccToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolAccToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullAccToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedAccToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarStackToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegStackToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccStackToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackStackToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstStackToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32StackToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32StackToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32StackToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolStackToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullStackToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedStackToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarConstToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegConstToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccConstToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackConstToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstConstToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32ConstToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32ConstToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32ConstToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolConstToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullConstToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedConstToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarF32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegF32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccF32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackF32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstF32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32F32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32F32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32F32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolF32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullF32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarI32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegI32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccI32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackI32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstI32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32I32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32I32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32I32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolI32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullI32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarU32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegU32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccU32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackU32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstU32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32U32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32U32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32U32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolU32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullU32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarBoolToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegBoolToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccBoolToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackBoolToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstBoolToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32BoolToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32BoolToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32BoolToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolBoolToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullBoolToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarNullToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegNullToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccNullToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackNullToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstNullToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32NullToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32NullToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32NullToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolNullToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullNullToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedNullToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarUndefinedToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegUndefinedToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccUndefinedToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackUndefinedToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstUndefinedToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32UndefinedToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32UndefinedToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32UndefinedToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullUndefinedToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarVarToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegVarToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccVarToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackVarToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstVarToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32VarToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32VarToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32VarToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolVarToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullVarToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedVarToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarRegToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegRegToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccRegToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackRegToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstRegToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32RegToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32RegToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32RegToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolRegToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullRegToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedRegToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarAccToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegAccToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccAccToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackAccToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstAccToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32AccToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32AccToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32AccToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolAccToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullAccToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedAccToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarStackToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegStackToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccStackToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackStackToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstStackToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32StackToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32StackToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32StackToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolStackToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullStackToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedStackToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarConstToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegConstToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccConstToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackConstToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstConstToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32ConstToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32ConstToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32ConstToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolConstToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullConstToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedConstToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarF32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegF32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccF32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackF32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstF32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32F32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32F32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32F32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolF32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullF32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarI32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegI32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccI32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackI32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstI32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32I32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32I32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32I32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolI32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullI32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarU32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegU32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccU32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackU32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstU32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32U32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32U32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32U32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolU32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullU32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarBoolToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegBoolToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccBoolToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackBoolToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstBoolToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32BoolToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32BoolToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32BoolToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolBoolToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullBoolToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarNullToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegNullToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccNullToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackNullToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstNullToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32NullToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32NullToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32NullToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolNullToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullNullToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedNullToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarUndefinedToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegUndefinedToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccUndefinedToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackUndefinedToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstUndefinedToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32UndefinedToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32UndefinedToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32UndefinedToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullUndefinedToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarVarToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegVarToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccVarToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackVarToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstVarToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32VarToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32VarToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32VarToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolVarToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullVarToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarRegToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegRegToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccRegToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackRegToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstRegToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32RegToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32RegToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32RegToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolRegToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullRegToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarAccToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegAccToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccAccToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackAccToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstAccToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32AccToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32AccToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32AccToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolAccToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullAccToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarStackToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegStackToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccStackToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackStackToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstStackToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32StackToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32StackToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32StackToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolStackToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullStackToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarConstToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegConstToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccConstToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackConstToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstConstToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32ConstToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32ConstToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32ConstToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolConstToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullConstToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarF32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegF32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccF32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackF32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstF32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32F32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32F32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32F32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolF32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullF32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarI32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegI32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccI32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackI32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstI32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32I32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32I32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32I32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolI32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullI32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarU32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegU32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccU32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackU32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstU32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32U32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32U32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32U32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolU32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullU32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarBoolToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegBoolToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccBoolToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackBoolToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstBoolToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32BoolToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32BoolToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32BoolToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolBoolToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullBoolToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarNullToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegNullToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccNullToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackNullToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstNullToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32NullToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32NullToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32NullToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolNullToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullNullToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarVarToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegVarToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccVarToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackVarToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstVarToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32VarToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32VarToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32VarToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolVarToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullVarToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedVarToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarRegToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegRegToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccRegToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackRegToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstRegToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32RegToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32RegToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32RegToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolRegToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullRegToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedRegToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarAccToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegAccToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccAccToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackAccToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstAccToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32AccToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32AccToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32AccToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolAccToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullAccToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedAccToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarStackToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegStackToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccStackToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackStackToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstStackToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32StackToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32StackToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32StackToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolStackToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullStackToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedStackToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarConstToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegConstToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccConstToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackConstToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstConstToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32ConstToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32ConstToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32ConstToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolConstToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullConstToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedConstToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarF32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegF32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccF32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackF32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstF32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32F32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32F32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32F32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolF32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullF32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarI32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegI32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccI32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackI32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstI32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32I32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32I32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32I32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolI32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullI32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarU32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegU32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccU32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackU32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstU32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32U32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32U32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32U32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolU32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullU32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarBoolToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegBoolToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccBoolToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackBoolToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstBoolToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32BoolToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32BoolToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32BoolToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolBoolToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullBoolToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarNullToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegNullToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccNullToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackNullToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstNullToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32NullToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32NullToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32NullToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolNullToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullNullToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedNullToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivVarUndefinedToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivRegUndefinedToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivAccUndefinedToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivStackUndefinedToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivConstUndefinedToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivF32UndefinedToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivI32UndefinedToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivU32UndefinedToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivNullUndefinedToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::DivUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::div(arg0, arg1, output, vm)?
            }
            Self::ModVarVarToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegVarToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccVarToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackVarToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstVarToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32VarToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32VarToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32VarToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolVarToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullVarToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedVarToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarRegToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegRegToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccRegToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackRegToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstRegToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32RegToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32RegToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32RegToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolRegToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullRegToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedRegToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarAccToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegAccToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccAccToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackAccToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstAccToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32AccToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32AccToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32AccToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolAccToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullAccToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedAccToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarStackToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegStackToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccStackToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackStackToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstStackToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32StackToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32StackToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32StackToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolStackToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullStackToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedStackToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarConstToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegConstToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccConstToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackConstToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstConstToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32ConstToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32ConstToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32ConstToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolConstToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullConstToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedConstToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarF32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegF32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccF32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackF32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstF32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32F32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32F32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32F32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolF32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullF32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarI32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegI32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccI32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackI32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstI32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32I32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32I32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32I32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolI32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullI32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarU32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegU32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccU32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackU32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstU32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32U32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32U32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32U32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolU32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullU32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarBoolToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegBoolToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccBoolToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackBoolToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstBoolToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32BoolToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32BoolToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32BoolToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolBoolToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullBoolToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarNullToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegNullToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccNullToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackNullToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstNullToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32NullToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32NullToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32NullToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolNullToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullNullToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedNullToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarUndefinedToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegUndefinedToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccUndefinedToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackUndefinedToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstUndefinedToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32UndefinedToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32UndefinedToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32UndefinedToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullUndefinedToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarVarToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegVarToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccVarToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackVarToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstVarToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32VarToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32VarToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32VarToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolVarToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullVarToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedVarToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarRegToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegRegToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccRegToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackRegToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstRegToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32RegToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32RegToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32RegToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolRegToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullRegToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedRegToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarAccToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegAccToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccAccToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackAccToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstAccToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32AccToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32AccToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32AccToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolAccToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullAccToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedAccToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarStackToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegStackToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccStackToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackStackToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstStackToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32StackToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32StackToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32StackToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolStackToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullStackToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedStackToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarConstToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegConstToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccConstToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackConstToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstConstToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32ConstToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32ConstToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32ConstToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolConstToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullConstToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedConstToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarF32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegF32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccF32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackF32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstF32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32F32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32F32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32F32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolF32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullF32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarI32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegI32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccI32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackI32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstI32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32I32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32I32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32I32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolI32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullI32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarU32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegU32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccU32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackU32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstU32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32U32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32U32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32U32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolU32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullU32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarBoolToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegBoolToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccBoolToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackBoolToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstBoolToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32BoolToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32BoolToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32BoolToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolBoolToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullBoolToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarNullToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegNullToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccNullToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackNullToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstNullToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32NullToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32NullToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32NullToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolNullToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullNullToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedNullToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarUndefinedToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegUndefinedToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccUndefinedToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackUndefinedToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstUndefinedToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32UndefinedToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32UndefinedToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32UndefinedToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullUndefinedToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarVarToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegVarToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccVarToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackVarToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstVarToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32VarToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32VarToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32VarToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolVarToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullVarToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarRegToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegRegToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccRegToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackRegToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstRegToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32RegToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32RegToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32RegToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolRegToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullRegToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarAccToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegAccToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccAccToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackAccToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstAccToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32AccToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32AccToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32AccToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolAccToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullAccToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarStackToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegStackToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccStackToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackStackToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstStackToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32StackToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32StackToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32StackToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolStackToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullStackToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarConstToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegConstToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccConstToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackConstToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstConstToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32ConstToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32ConstToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32ConstToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolConstToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullConstToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarF32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegF32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccF32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackF32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstF32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32F32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32F32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32F32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolF32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullF32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarI32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegI32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccI32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackI32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstI32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32I32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32I32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32I32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolI32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullI32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarU32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegU32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccU32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackU32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstU32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32U32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32U32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32U32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolU32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullU32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarBoolToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegBoolToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccBoolToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackBoolToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstBoolToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32BoolToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32BoolToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32BoolToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolBoolToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullBoolToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarNullToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegNullToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccNullToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackNullToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstNullToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32NullToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32NullToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32NullToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolNullToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullNullToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarVarToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegVarToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccVarToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackVarToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstVarToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32VarToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32VarToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32VarToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolVarToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullVarToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedVarToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarRegToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegRegToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccRegToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackRegToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstRegToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32RegToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32RegToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32RegToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolRegToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullRegToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedRegToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarAccToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegAccToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccAccToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackAccToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstAccToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32AccToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32AccToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32AccToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolAccToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullAccToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedAccToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarStackToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegStackToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccStackToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackStackToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstStackToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32StackToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32StackToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32StackToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolStackToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullStackToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedStackToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarConstToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegConstToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccConstToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackConstToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstConstToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32ConstToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32ConstToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32ConstToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolConstToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullConstToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedConstToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarF32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegF32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccF32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackF32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstF32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32F32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32F32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32F32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolF32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullF32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarI32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegI32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccI32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackI32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstI32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32I32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32I32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32I32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolI32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullI32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarU32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegU32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccU32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackU32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstU32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32U32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32U32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32U32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolU32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullU32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarBoolToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegBoolToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccBoolToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackBoolToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstBoolToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32BoolToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32BoolToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32BoolToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolBoolToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullBoolToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarNullToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegNullToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccNullToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackNullToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstNullToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32NullToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32NullToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32NullToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolNullToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullNullToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedNullToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModVarUndefinedToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModRegUndefinedToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModAccUndefinedToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModStackUndefinedToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModConstUndefinedToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModF32UndefinedToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModI32UndefinedToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModU32UndefinedToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModNullUndefinedToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::ModUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::mod_(arg0, arg1, output, vm)?
            }
            Self::LNotVarToVar(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotRegToVar(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotAccToVar(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotStackToVar(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotConstToVar(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotF32ToVar(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotI32ToVar(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotU32ToVar(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotBoolToVar(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotNullToVar(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotUndefinedToVar(arg0, output) => {
                instruction::l_not(arg0, output, vm)?
            }
            Self::LNotVarToReg(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotRegToReg(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotAccToReg(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotStackToReg(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotConstToReg(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotF32ToReg(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotI32ToReg(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotU32ToReg(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotBoolToReg(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotNullToReg(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotUndefinedToReg(arg0, output) => {
                instruction::l_not(arg0, output, vm)?
            }
            Self::LNotVarToAcc(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotRegToAcc(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotAccToAcc(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotStackToAcc(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotConstToAcc(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotF32ToAcc(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotI32ToAcc(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotU32ToAcc(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotBoolToAcc(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotNullToAcc(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotUndefinedToAcc(arg0, output) => {
                instruction::l_not(arg0, output, vm)?
            }
            Self::LNotVarToStack(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotRegToStack(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotAccToStack(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotStackToStack(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotConstToStack(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotF32ToStack(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotI32ToStack(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotU32ToStack(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotBoolToStack(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotNullToStack(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LNotUndefinedToStack(arg0, output) => {
                instruction::l_not(arg0, output, vm)?
            }
            Self::LOrVarVarToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegVarToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccVarToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackVarToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstVarToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32VarToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32VarToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32VarToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolVarToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullVarToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedVarToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarRegToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegRegToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccRegToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackRegToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstRegToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32RegToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32RegToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32RegToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolRegToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullRegToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedRegToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarAccToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegAccToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccAccToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackAccToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstAccToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32AccToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32AccToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32AccToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolAccToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullAccToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedAccToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarStackToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegStackToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccStackToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackStackToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstStackToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32StackToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32StackToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32StackToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolStackToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullStackToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedStackToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarConstToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegConstToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccConstToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackConstToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstConstToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32ConstToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32ConstToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32ConstToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolConstToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullConstToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedConstToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarF32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegF32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccF32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackF32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstF32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32F32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32F32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32F32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolF32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullF32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarI32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegI32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccI32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackI32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstI32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32I32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32I32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32I32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolI32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullI32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarU32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegU32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccU32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackU32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstU32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32U32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32U32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32U32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolU32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullU32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarBoolToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegBoolToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccBoolToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackBoolToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstBoolToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32BoolToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32BoolToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32BoolToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolBoolToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullBoolToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarNullToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegNullToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccNullToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackNullToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstNullToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32NullToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32NullToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32NullToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolNullToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullNullToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedNullToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarUndefinedToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegUndefinedToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccUndefinedToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackUndefinedToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstUndefinedToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32UndefinedToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32UndefinedToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32UndefinedToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullUndefinedToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarVarToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegVarToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccVarToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackVarToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstVarToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32VarToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32VarToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32VarToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolVarToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullVarToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedVarToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarRegToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegRegToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccRegToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackRegToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstRegToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32RegToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32RegToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32RegToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolRegToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullRegToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedRegToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarAccToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegAccToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccAccToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackAccToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstAccToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32AccToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32AccToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32AccToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolAccToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullAccToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedAccToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarStackToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegStackToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccStackToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackStackToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstStackToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32StackToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32StackToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32StackToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolStackToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullStackToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedStackToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarConstToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegConstToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccConstToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackConstToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstConstToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32ConstToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32ConstToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32ConstToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolConstToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullConstToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedConstToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarF32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegF32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccF32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackF32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstF32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32F32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32F32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32F32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolF32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullF32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarI32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegI32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccI32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackI32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstI32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32I32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32I32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32I32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolI32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullI32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarU32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegU32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccU32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackU32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstU32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32U32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32U32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32U32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolU32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullU32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarBoolToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegBoolToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccBoolToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackBoolToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstBoolToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32BoolToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32BoolToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32BoolToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolBoolToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullBoolToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarNullToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegNullToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccNullToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackNullToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstNullToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32NullToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32NullToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32NullToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolNullToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullNullToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedNullToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarUndefinedToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegUndefinedToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccUndefinedToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackUndefinedToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstUndefinedToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32UndefinedToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32UndefinedToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32UndefinedToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullUndefinedToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarVarToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegVarToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccVarToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackVarToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstVarToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32VarToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32VarToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32VarToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolVarToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullVarToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarRegToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegRegToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccRegToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackRegToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstRegToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32RegToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32RegToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32RegToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolRegToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullRegToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarAccToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegAccToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccAccToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackAccToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstAccToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32AccToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32AccToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32AccToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolAccToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullAccToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarStackToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegStackToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccStackToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackStackToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstStackToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32StackToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32StackToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32StackToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolStackToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullStackToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarConstToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegConstToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccConstToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackConstToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstConstToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32ConstToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32ConstToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32ConstToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolConstToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullConstToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarF32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegF32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccF32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackF32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstF32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32F32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32F32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32F32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolF32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullF32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarI32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegI32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccI32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackI32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstI32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32I32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32I32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32I32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolI32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullI32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarU32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegU32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccU32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackU32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstU32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32U32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32U32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32U32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolU32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullU32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarBoolToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegBoolToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccBoolToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackBoolToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstBoolToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32BoolToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32BoolToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32BoolToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolBoolToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullBoolToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarNullToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegNullToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccNullToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackNullToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstNullToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32NullToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32NullToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32NullToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolNullToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullNullToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarVarToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegVarToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccVarToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackVarToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstVarToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32VarToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32VarToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32VarToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolVarToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullVarToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedVarToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarRegToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegRegToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccRegToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackRegToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstRegToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32RegToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32RegToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32RegToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolRegToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullRegToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedRegToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarAccToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegAccToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccAccToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackAccToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstAccToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32AccToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32AccToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32AccToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolAccToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullAccToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedAccToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarStackToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegStackToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccStackToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackStackToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstStackToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32StackToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32StackToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32StackToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolStackToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullStackToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedStackToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarConstToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegConstToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccConstToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackConstToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstConstToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32ConstToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32ConstToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32ConstToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolConstToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullConstToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedConstToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarF32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegF32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccF32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackF32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstF32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32F32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32F32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32F32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolF32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullF32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarI32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegI32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccI32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackI32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstI32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32I32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32I32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32I32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolI32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullI32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarU32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegU32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccU32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackU32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstU32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32U32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32U32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32U32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolU32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullU32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarBoolToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegBoolToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccBoolToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackBoolToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstBoolToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32BoolToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32BoolToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32BoolToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolBoolToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullBoolToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarNullToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegNullToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccNullToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackNullToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstNullToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32NullToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32NullToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32NullToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolNullToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullNullToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedNullToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrVarUndefinedToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrRegUndefinedToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrAccUndefinedToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrStackUndefinedToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrConstUndefinedToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrF32UndefinedToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrI32UndefinedToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrU32UndefinedToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrNullUndefinedToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LOrUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::l_or(arg0, arg1, output, vm)?
            }
            Self::LAndVarVarToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegVarToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccVarToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackVarToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstVarToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32VarToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32VarToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32VarToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolVarToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullVarToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedVarToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarRegToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegRegToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccRegToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackRegToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstRegToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32RegToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32RegToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32RegToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolRegToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullRegToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedRegToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarAccToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegAccToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccAccToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackAccToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstAccToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32AccToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32AccToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32AccToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolAccToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullAccToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedAccToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarStackToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegStackToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccStackToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackStackToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstStackToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32StackToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32StackToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32StackToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolStackToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullStackToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedStackToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarConstToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegConstToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccConstToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackConstToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstConstToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32ConstToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32ConstToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32ConstToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolConstToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullConstToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedConstToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarF32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegF32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccF32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackF32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstF32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32F32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32F32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32F32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolF32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullF32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarI32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegI32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccI32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackI32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstI32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32I32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32I32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32I32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolI32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullI32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarU32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegU32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccU32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackU32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstU32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32U32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32U32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32U32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolU32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullU32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarBoolToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegBoolToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccBoolToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackBoolToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstBoolToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32BoolToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32BoolToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32BoolToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolBoolToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullBoolToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarNullToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegNullToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccNullToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackNullToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstNullToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32NullToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32NullToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32NullToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolNullToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullNullToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedNullToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarUndefinedToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegUndefinedToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccUndefinedToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackUndefinedToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstUndefinedToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32UndefinedToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32UndefinedToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32UndefinedToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullUndefinedToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarVarToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegVarToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccVarToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackVarToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstVarToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32VarToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32VarToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32VarToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolVarToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullVarToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedVarToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarRegToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegRegToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccRegToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackRegToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstRegToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32RegToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32RegToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32RegToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolRegToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullRegToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedRegToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarAccToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegAccToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccAccToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackAccToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstAccToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32AccToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32AccToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32AccToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolAccToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullAccToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedAccToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarStackToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegStackToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccStackToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackStackToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstStackToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32StackToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32StackToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32StackToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolStackToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullStackToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedStackToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarConstToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegConstToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccConstToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackConstToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstConstToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32ConstToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32ConstToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32ConstToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolConstToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullConstToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedConstToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarF32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegF32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccF32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackF32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstF32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32F32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32F32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32F32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolF32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullF32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarI32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegI32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccI32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackI32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstI32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32I32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32I32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32I32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolI32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullI32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarU32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegU32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccU32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackU32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstU32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32U32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32U32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32U32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolU32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullU32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarBoolToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegBoolToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccBoolToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackBoolToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstBoolToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32BoolToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32BoolToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32BoolToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolBoolToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullBoolToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarNullToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegNullToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccNullToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackNullToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstNullToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32NullToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32NullToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32NullToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolNullToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullNullToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedNullToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarUndefinedToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegUndefinedToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccUndefinedToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackUndefinedToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstUndefinedToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32UndefinedToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32UndefinedToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32UndefinedToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullUndefinedToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarVarToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegVarToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccVarToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackVarToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstVarToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32VarToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32VarToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32VarToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolVarToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullVarToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarRegToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegRegToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccRegToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackRegToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstRegToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32RegToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32RegToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32RegToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolRegToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullRegToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarAccToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegAccToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccAccToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackAccToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstAccToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32AccToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32AccToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32AccToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolAccToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullAccToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarStackToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegStackToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccStackToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackStackToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstStackToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32StackToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32StackToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32StackToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolStackToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullStackToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarConstToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegConstToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccConstToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackConstToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstConstToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32ConstToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32ConstToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32ConstToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolConstToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullConstToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarF32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegF32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccF32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackF32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstF32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32F32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32F32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32F32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolF32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullF32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarI32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegI32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccI32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackI32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstI32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32I32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32I32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32I32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolI32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullI32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarU32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegU32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccU32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackU32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstU32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32U32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32U32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32U32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolU32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullU32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarBoolToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegBoolToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccBoolToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackBoolToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstBoolToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32BoolToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32BoolToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32BoolToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolBoolToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullBoolToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarNullToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegNullToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccNullToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackNullToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstNullToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32NullToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32NullToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32NullToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolNullToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullNullToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarVarToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegVarToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccVarToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackVarToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstVarToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32VarToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32VarToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32VarToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolVarToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullVarToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedVarToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarRegToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegRegToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccRegToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackRegToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstRegToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32RegToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32RegToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32RegToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolRegToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullRegToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedRegToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarAccToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegAccToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccAccToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackAccToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstAccToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32AccToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32AccToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32AccToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolAccToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullAccToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedAccToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarStackToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegStackToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccStackToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackStackToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstStackToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32StackToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32StackToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32StackToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolStackToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullStackToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedStackToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarConstToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegConstToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccConstToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackConstToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstConstToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32ConstToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32ConstToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32ConstToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolConstToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullConstToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedConstToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarF32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegF32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccF32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackF32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstF32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32F32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32F32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32F32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolF32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullF32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarI32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegI32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccI32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackI32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstI32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32I32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32I32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32I32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolI32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullI32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarU32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegU32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccU32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackU32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstU32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32U32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32U32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32U32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolU32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullU32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarBoolToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegBoolToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccBoolToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackBoolToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstBoolToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32BoolToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32BoolToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32BoolToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolBoolToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullBoolToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarNullToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegNullToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccNullToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackNullToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstNullToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32NullToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32NullToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32NullToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolNullToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullNullToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedNullToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndVarUndefinedToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndRegUndefinedToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndAccUndefinedToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndStackUndefinedToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndConstUndefinedToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndF32UndefinedToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndI32UndefinedToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndU32UndefinedToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndNullUndefinedToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::LAndUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::l_and(arg0, arg1, output, vm)?
            }
            Self::BXorVarVarToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegVarToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccVarToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackVarToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstVarToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32VarToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32VarToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32VarToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolVarToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullVarToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedVarToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarRegToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegRegToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccRegToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackRegToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstRegToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32RegToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32RegToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32RegToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolRegToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullRegToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedRegToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarAccToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegAccToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccAccToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackAccToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstAccToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32AccToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32AccToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32AccToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolAccToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullAccToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedAccToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarStackToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegStackToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccStackToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackStackToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstStackToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32StackToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32StackToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32StackToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolStackToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullStackToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedStackToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarConstToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegConstToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccConstToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackConstToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstConstToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32ConstToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32ConstToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32ConstToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolConstToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullConstToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedConstToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarF32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegF32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccF32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackF32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstF32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32F32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32F32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32F32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolF32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullF32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarI32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegI32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccI32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackI32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstI32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32I32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32I32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32I32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolI32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullI32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarU32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegU32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccU32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackU32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstU32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32U32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32U32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32U32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolU32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullU32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarBoolToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegBoolToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccBoolToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackBoolToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstBoolToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32BoolToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32BoolToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32BoolToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolBoolToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullBoolToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarNullToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegNullToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccNullToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackNullToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstNullToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32NullToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32NullToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32NullToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolNullToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullNullToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedNullToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarUndefinedToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegUndefinedToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccUndefinedToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackUndefinedToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstUndefinedToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32UndefinedToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32UndefinedToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32UndefinedToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullUndefinedToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarVarToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegVarToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccVarToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackVarToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstVarToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32VarToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32VarToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32VarToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolVarToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullVarToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedVarToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarRegToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegRegToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccRegToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackRegToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstRegToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32RegToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32RegToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32RegToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolRegToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullRegToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedRegToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarAccToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegAccToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccAccToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackAccToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstAccToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32AccToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32AccToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32AccToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolAccToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullAccToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedAccToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarStackToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegStackToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccStackToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackStackToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstStackToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32StackToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32StackToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32StackToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolStackToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullStackToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedStackToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarConstToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegConstToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccConstToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackConstToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstConstToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32ConstToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32ConstToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32ConstToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolConstToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullConstToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedConstToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarF32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegF32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccF32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackF32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstF32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32F32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32F32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32F32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolF32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullF32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarI32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegI32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccI32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackI32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstI32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32I32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32I32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32I32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolI32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullI32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarU32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegU32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccU32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackU32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstU32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32U32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32U32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32U32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolU32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullU32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarBoolToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegBoolToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccBoolToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackBoolToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstBoolToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32BoolToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32BoolToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32BoolToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolBoolToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullBoolToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarNullToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegNullToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccNullToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackNullToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstNullToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32NullToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32NullToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32NullToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolNullToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullNullToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedNullToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarUndefinedToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegUndefinedToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccUndefinedToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackUndefinedToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstUndefinedToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32UndefinedToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32UndefinedToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32UndefinedToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullUndefinedToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarVarToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegVarToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccVarToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackVarToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstVarToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32VarToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32VarToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32VarToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolVarToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullVarToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarRegToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegRegToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccRegToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackRegToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstRegToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32RegToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32RegToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32RegToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolRegToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullRegToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarAccToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegAccToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccAccToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackAccToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstAccToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32AccToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32AccToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32AccToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolAccToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullAccToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarStackToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegStackToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccStackToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackStackToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstStackToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32StackToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32StackToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32StackToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolStackToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullStackToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarConstToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegConstToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccConstToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackConstToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstConstToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32ConstToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32ConstToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32ConstToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolConstToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullConstToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarF32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegF32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccF32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackF32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstF32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32F32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32F32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32F32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolF32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullF32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarI32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegI32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccI32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackI32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstI32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32I32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32I32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32I32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolI32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullI32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarU32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegU32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccU32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackU32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstU32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32U32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32U32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32U32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolU32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullU32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarBoolToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegBoolToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccBoolToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackBoolToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstBoolToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32BoolToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32BoolToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32BoolToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolBoolToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullBoolToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarNullToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegNullToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccNullToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackNullToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstNullToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32NullToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32NullToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32NullToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolNullToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullNullToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarVarToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegVarToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccVarToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackVarToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstVarToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32VarToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32VarToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32VarToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolVarToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullVarToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedVarToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarRegToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegRegToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccRegToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackRegToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstRegToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32RegToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32RegToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32RegToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolRegToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullRegToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedRegToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarAccToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegAccToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccAccToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackAccToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstAccToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32AccToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32AccToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32AccToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolAccToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullAccToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedAccToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarStackToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegStackToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccStackToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackStackToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstStackToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32StackToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32StackToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32StackToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolStackToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullStackToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedStackToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarConstToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegConstToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccConstToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackConstToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstConstToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32ConstToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32ConstToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32ConstToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolConstToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullConstToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedConstToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarF32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegF32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccF32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackF32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstF32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32F32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32F32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32F32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolF32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullF32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarI32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegI32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccI32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackI32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstI32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32I32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32I32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32I32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolI32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullI32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarU32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegU32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccU32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackU32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstU32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32U32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32U32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32U32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolU32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullU32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarBoolToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegBoolToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccBoolToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackBoolToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstBoolToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32BoolToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32BoolToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32BoolToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolBoolToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullBoolToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarNullToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegNullToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccNullToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackNullToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstNullToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32NullToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32NullToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32NullToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolNullToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullNullToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedNullToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorVarUndefinedToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorRegUndefinedToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorAccUndefinedToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorStackUndefinedToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorConstUndefinedToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorF32UndefinedToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorI32UndefinedToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorU32UndefinedToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorNullUndefinedToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BXorUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::b_xor(arg0, arg1, output, vm)?
            }
            Self::BOrVarVarToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegVarToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccVarToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackVarToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstVarToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32VarToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32VarToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32VarToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolVarToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullVarToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedVarToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarRegToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegRegToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccRegToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackRegToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstRegToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32RegToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32RegToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32RegToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolRegToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullRegToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedRegToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarAccToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegAccToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccAccToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackAccToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstAccToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32AccToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32AccToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32AccToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolAccToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullAccToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedAccToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarStackToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegStackToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccStackToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackStackToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstStackToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32StackToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32StackToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32StackToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolStackToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullStackToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedStackToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarConstToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegConstToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccConstToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackConstToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstConstToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32ConstToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32ConstToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32ConstToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolConstToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullConstToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedConstToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarF32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegF32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccF32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackF32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstF32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32F32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32F32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32F32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolF32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullF32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarI32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegI32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccI32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackI32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstI32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32I32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32I32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32I32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolI32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullI32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarU32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegU32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccU32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackU32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstU32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32U32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32U32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32U32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolU32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullU32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarBoolToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegBoolToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccBoolToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackBoolToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstBoolToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32BoolToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32BoolToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32BoolToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolBoolToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullBoolToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarNullToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegNullToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccNullToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackNullToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstNullToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32NullToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32NullToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32NullToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolNullToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullNullToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedNullToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarUndefinedToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegUndefinedToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccUndefinedToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackUndefinedToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstUndefinedToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32UndefinedToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32UndefinedToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32UndefinedToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullUndefinedToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarVarToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegVarToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccVarToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackVarToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstVarToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32VarToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32VarToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32VarToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolVarToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullVarToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedVarToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarRegToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegRegToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccRegToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackRegToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstRegToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32RegToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32RegToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32RegToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolRegToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullRegToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedRegToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarAccToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegAccToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccAccToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackAccToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstAccToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32AccToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32AccToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32AccToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolAccToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullAccToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedAccToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarStackToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegStackToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccStackToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackStackToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstStackToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32StackToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32StackToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32StackToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolStackToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullStackToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedStackToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarConstToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegConstToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccConstToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackConstToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstConstToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32ConstToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32ConstToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32ConstToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolConstToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullConstToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedConstToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarF32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegF32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccF32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackF32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstF32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32F32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32F32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32F32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolF32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullF32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarI32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegI32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccI32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackI32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstI32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32I32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32I32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32I32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolI32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullI32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarU32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegU32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccU32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackU32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstU32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32U32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32U32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32U32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolU32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullU32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarBoolToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegBoolToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccBoolToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackBoolToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstBoolToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32BoolToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32BoolToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32BoolToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolBoolToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullBoolToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarNullToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegNullToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccNullToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackNullToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstNullToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32NullToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32NullToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32NullToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolNullToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullNullToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedNullToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarUndefinedToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegUndefinedToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccUndefinedToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackUndefinedToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstUndefinedToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32UndefinedToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32UndefinedToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32UndefinedToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullUndefinedToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarVarToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegVarToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccVarToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackVarToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstVarToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32VarToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32VarToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32VarToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolVarToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullVarToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarRegToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegRegToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccRegToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackRegToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstRegToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32RegToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32RegToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32RegToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolRegToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullRegToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarAccToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegAccToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccAccToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackAccToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstAccToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32AccToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32AccToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32AccToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolAccToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullAccToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarStackToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegStackToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccStackToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackStackToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstStackToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32StackToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32StackToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32StackToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolStackToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullStackToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarConstToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegConstToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccConstToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackConstToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstConstToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32ConstToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32ConstToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32ConstToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolConstToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullConstToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarF32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegF32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccF32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackF32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstF32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32F32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32F32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32F32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolF32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullF32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarI32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegI32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccI32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackI32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstI32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32I32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32I32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32I32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolI32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullI32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarU32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegU32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccU32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackU32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstU32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32U32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32U32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32U32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolU32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullU32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarBoolToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegBoolToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccBoolToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackBoolToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstBoolToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32BoolToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32BoolToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32BoolToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolBoolToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullBoolToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarNullToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegNullToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccNullToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackNullToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstNullToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32NullToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32NullToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32NullToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolNullToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullNullToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarVarToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegVarToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccVarToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackVarToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstVarToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32VarToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32VarToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32VarToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolVarToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullVarToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedVarToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarRegToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegRegToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccRegToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackRegToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstRegToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32RegToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32RegToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32RegToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolRegToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullRegToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedRegToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarAccToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegAccToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccAccToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackAccToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstAccToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32AccToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32AccToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32AccToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolAccToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullAccToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedAccToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarStackToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegStackToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccStackToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackStackToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstStackToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32StackToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32StackToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32StackToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolStackToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullStackToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedStackToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarConstToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegConstToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccConstToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackConstToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstConstToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32ConstToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32ConstToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32ConstToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolConstToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullConstToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedConstToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarF32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegF32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccF32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackF32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstF32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32F32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32F32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32F32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolF32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullF32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarI32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegI32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccI32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackI32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstI32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32I32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32I32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32I32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolI32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullI32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarU32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegU32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccU32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackU32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstU32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32U32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32U32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32U32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolU32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullU32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarBoolToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegBoolToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccBoolToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackBoolToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstBoolToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32BoolToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32BoolToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32BoolToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolBoolToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullBoolToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarNullToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegNullToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccNullToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackNullToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstNullToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32NullToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32NullToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32NullToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolNullToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullNullToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedNullToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrVarUndefinedToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrRegUndefinedToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrAccUndefinedToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrStackUndefinedToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrConstUndefinedToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrF32UndefinedToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrI32UndefinedToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrU32UndefinedToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrNullUndefinedToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BOrUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::b_or(arg0, arg1, output, vm)?
            }
            Self::BAndVarVarToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegVarToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccVarToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackVarToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstVarToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32VarToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32VarToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32VarToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolVarToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullVarToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedVarToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarRegToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegRegToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccRegToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackRegToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstRegToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32RegToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32RegToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32RegToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolRegToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullRegToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedRegToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarAccToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegAccToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccAccToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackAccToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstAccToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32AccToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32AccToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32AccToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolAccToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullAccToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedAccToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarStackToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegStackToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccStackToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackStackToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstStackToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32StackToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32StackToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32StackToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolStackToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullStackToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedStackToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarConstToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegConstToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccConstToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackConstToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstConstToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32ConstToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32ConstToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32ConstToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolConstToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullConstToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedConstToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarF32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegF32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccF32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackF32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstF32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32F32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32F32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32F32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolF32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullF32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarI32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegI32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccI32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackI32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstI32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32I32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32I32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32I32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolI32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullI32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarU32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegU32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccU32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackU32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstU32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32U32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32U32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32U32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolU32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullU32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarBoolToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegBoolToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccBoolToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackBoolToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstBoolToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32BoolToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32BoolToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32BoolToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolBoolToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullBoolToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarNullToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegNullToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccNullToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackNullToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstNullToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32NullToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32NullToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32NullToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolNullToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullNullToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedNullToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarUndefinedToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegUndefinedToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccUndefinedToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackUndefinedToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstUndefinedToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32UndefinedToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32UndefinedToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32UndefinedToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullUndefinedToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarVarToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegVarToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccVarToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackVarToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstVarToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32VarToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32VarToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32VarToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolVarToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullVarToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedVarToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarRegToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegRegToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccRegToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackRegToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstRegToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32RegToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32RegToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32RegToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolRegToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullRegToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedRegToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarAccToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegAccToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccAccToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackAccToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstAccToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32AccToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32AccToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32AccToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolAccToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullAccToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedAccToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarStackToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegStackToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccStackToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackStackToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstStackToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32StackToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32StackToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32StackToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolStackToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullStackToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedStackToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarConstToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegConstToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccConstToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackConstToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstConstToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32ConstToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32ConstToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32ConstToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolConstToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullConstToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedConstToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarF32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegF32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccF32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackF32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstF32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32F32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32F32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32F32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolF32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullF32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarI32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegI32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccI32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackI32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstI32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32I32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32I32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32I32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolI32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullI32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarU32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegU32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccU32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackU32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstU32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32U32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32U32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32U32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolU32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullU32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarBoolToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegBoolToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccBoolToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackBoolToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstBoolToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32BoolToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32BoolToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32BoolToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolBoolToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullBoolToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarNullToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegNullToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccNullToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackNullToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstNullToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32NullToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32NullToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32NullToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolNullToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullNullToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedNullToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarUndefinedToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegUndefinedToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccUndefinedToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackUndefinedToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstUndefinedToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32UndefinedToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32UndefinedToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32UndefinedToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullUndefinedToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarVarToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegVarToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccVarToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackVarToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstVarToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32VarToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32VarToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32VarToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolVarToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullVarToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarRegToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegRegToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccRegToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackRegToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstRegToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32RegToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32RegToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32RegToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolRegToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullRegToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarAccToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegAccToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccAccToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackAccToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstAccToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32AccToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32AccToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32AccToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolAccToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullAccToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarStackToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegStackToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccStackToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackStackToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstStackToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32StackToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32StackToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32StackToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolStackToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullStackToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarConstToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegConstToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccConstToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackConstToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstConstToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32ConstToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32ConstToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32ConstToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolConstToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullConstToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarF32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegF32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccF32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackF32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstF32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32F32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32F32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32F32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolF32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullF32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarI32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegI32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccI32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackI32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstI32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32I32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32I32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32I32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolI32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullI32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarU32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegU32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccU32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackU32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstU32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32U32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32U32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32U32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolU32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullU32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarBoolToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegBoolToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccBoolToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackBoolToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstBoolToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32BoolToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32BoolToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32BoolToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolBoolToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullBoolToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarNullToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegNullToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccNullToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackNullToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstNullToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32NullToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32NullToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32NullToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolNullToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullNullToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarVarToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegVarToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccVarToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackVarToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstVarToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32VarToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32VarToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32VarToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolVarToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullVarToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedVarToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarRegToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegRegToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccRegToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackRegToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstRegToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32RegToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32RegToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32RegToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolRegToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullRegToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedRegToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarAccToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegAccToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccAccToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackAccToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstAccToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32AccToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32AccToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32AccToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolAccToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullAccToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedAccToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarStackToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegStackToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccStackToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackStackToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstStackToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32StackToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32StackToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32StackToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolStackToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullStackToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedStackToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarConstToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegConstToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccConstToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackConstToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstConstToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32ConstToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32ConstToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32ConstToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolConstToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullConstToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedConstToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarF32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegF32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccF32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackF32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstF32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32F32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32F32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32F32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolF32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullF32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarI32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegI32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccI32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackI32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstI32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32I32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32I32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32I32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolI32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullI32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarU32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegU32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccU32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackU32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstU32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32U32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32U32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32U32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolU32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullU32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarBoolToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegBoolToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccBoolToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackBoolToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstBoolToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32BoolToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32BoolToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32BoolToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolBoolToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullBoolToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarNullToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegNullToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccNullToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackNullToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstNullToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32NullToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32NullToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32NullToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolNullToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullNullToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedNullToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndVarUndefinedToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndRegUndefinedToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndAccUndefinedToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndStackUndefinedToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndConstUndefinedToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndF32UndefinedToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndI32UndefinedToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndU32UndefinedToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndNullUndefinedToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::BAndUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::b_and(arg0, arg1, output, vm)?
            }
            Self::EqVarVarToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegVarToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccVarToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackVarToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstVarToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32VarToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32VarToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32VarToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolVarToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullVarToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedVarToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarRegToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegRegToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccRegToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackRegToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstRegToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32RegToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32RegToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32RegToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolRegToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullRegToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedRegToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarAccToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegAccToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccAccToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackAccToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstAccToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32AccToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32AccToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32AccToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolAccToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullAccToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedAccToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarStackToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegStackToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccStackToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackStackToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstStackToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32StackToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32StackToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32StackToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolStackToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullStackToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedStackToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarConstToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegConstToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccConstToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackConstToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstConstToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32ConstToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32ConstToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32ConstToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolConstToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullConstToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedConstToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarF32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegF32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccF32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackF32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstF32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32F32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32F32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32F32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolF32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullF32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarI32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegI32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccI32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackI32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstI32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32I32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32I32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32I32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolI32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullI32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarU32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegU32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccU32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackU32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstU32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32U32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32U32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32U32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolU32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullU32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarBoolToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegBoolToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccBoolToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackBoolToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstBoolToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32BoolToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32BoolToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32BoolToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolBoolToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullBoolToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarNullToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegNullToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccNullToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackNullToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstNullToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32NullToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32NullToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32NullToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolNullToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullNullToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedNullToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarUndefinedToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegUndefinedToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccUndefinedToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackUndefinedToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstUndefinedToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32UndefinedToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32UndefinedToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32UndefinedToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullUndefinedToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarVarToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegVarToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccVarToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackVarToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstVarToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32VarToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32VarToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32VarToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolVarToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullVarToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedVarToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarRegToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegRegToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccRegToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackRegToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstRegToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32RegToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32RegToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32RegToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolRegToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullRegToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedRegToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarAccToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegAccToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccAccToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackAccToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstAccToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32AccToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32AccToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32AccToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolAccToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullAccToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedAccToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarStackToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegStackToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccStackToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackStackToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstStackToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32StackToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32StackToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32StackToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolStackToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullStackToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedStackToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarConstToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegConstToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccConstToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackConstToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstConstToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32ConstToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32ConstToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32ConstToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolConstToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullConstToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedConstToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarF32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegF32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccF32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackF32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstF32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32F32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32F32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32F32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolF32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullF32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarI32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegI32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccI32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackI32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstI32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32I32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32I32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32I32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolI32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullI32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarU32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegU32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccU32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackU32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstU32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32U32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32U32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32U32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolU32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullU32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarBoolToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegBoolToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccBoolToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackBoolToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstBoolToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32BoolToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32BoolToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32BoolToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolBoolToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullBoolToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarNullToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegNullToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccNullToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackNullToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstNullToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32NullToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32NullToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32NullToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolNullToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullNullToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedNullToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarUndefinedToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegUndefinedToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccUndefinedToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackUndefinedToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstUndefinedToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32UndefinedToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32UndefinedToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32UndefinedToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullUndefinedToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarVarToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegVarToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccVarToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackVarToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstVarToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32VarToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32VarToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32VarToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolVarToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullVarToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarRegToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegRegToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccRegToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackRegToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstRegToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32RegToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32RegToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32RegToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolRegToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullRegToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarAccToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegAccToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccAccToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackAccToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstAccToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32AccToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32AccToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32AccToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolAccToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullAccToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarStackToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegStackToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccStackToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackStackToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstStackToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32StackToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32StackToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32StackToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolStackToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullStackToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarConstToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegConstToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccConstToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackConstToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstConstToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32ConstToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32ConstToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32ConstToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolConstToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullConstToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarF32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegF32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccF32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackF32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstF32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32F32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32F32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32F32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolF32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullF32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarI32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegI32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccI32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackI32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstI32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32I32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32I32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32I32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolI32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullI32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarU32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegU32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccU32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackU32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstU32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32U32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32U32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32U32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolU32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullU32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarBoolToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegBoolToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccBoolToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackBoolToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstBoolToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32BoolToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32BoolToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32BoolToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolBoolToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullBoolToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarNullToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegNullToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccNullToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackNullToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstNullToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32NullToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32NullToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32NullToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolNullToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullNullToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarVarToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegVarToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccVarToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackVarToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstVarToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32VarToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32VarToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32VarToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolVarToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullVarToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedVarToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarRegToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegRegToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccRegToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackRegToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstRegToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32RegToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32RegToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32RegToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolRegToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullRegToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedRegToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarAccToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegAccToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccAccToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackAccToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstAccToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32AccToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32AccToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32AccToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolAccToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullAccToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedAccToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarStackToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegStackToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccStackToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackStackToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstStackToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32StackToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32StackToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32StackToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolStackToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullStackToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedStackToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarConstToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegConstToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccConstToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackConstToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstConstToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32ConstToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32ConstToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32ConstToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolConstToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullConstToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedConstToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarF32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegF32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccF32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackF32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstF32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32F32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32F32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32F32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolF32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullF32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarI32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegI32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccI32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackI32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstI32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32I32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32I32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32I32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolI32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullI32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarU32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegU32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccU32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackU32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstU32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32U32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32U32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32U32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolU32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullU32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarBoolToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegBoolToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccBoolToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackBoolToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstBoolToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32BoolToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32BoolToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32BoolToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolBoolToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullBoolToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarNullToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegNullToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccNullToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackNullToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstNullToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32NullToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32NullToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32NullToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolNullToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullNullToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedNullToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqVarUndefinedToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqRegUndefinedToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqAccUndefinedToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqStackUndefinedToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqConstUndefinedToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqF32UndefinedToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqI32UndefinedToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqU32UndefinedToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqNullUndefinedToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::EqUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::eq(arg0, arg1, output, vm)?
            }
            Self::NeVarVarToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegVarToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccVarToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackVarToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstVarToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32VarToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32VarToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32VarToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolVarToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullVarToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedVarToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarRegToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegRegToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccRegToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackRegToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstRegToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32RegToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32RegToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32RegToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolRegToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullRegToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedRegToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarAccToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegAccToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccAccToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackAccToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstAccToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32AccToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32AccToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32AccToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolAccToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullAccToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedAccToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarStackToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegStackToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccStackToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackStackToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstStackToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32StackToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32StackToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32StackToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolStackToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullStackToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedStackToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarConstToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegConstToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccConstToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackConstToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstConstToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32ConstToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32ConstToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32ConstToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolConstToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullConstToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedConstToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarF32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegF32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccF32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackF32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstF32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32F32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32F32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32F32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolF32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullF32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarI32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegI32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccI32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackI32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstI32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32I32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32I32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32I32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolI32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullI32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarU32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegU32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccU32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackU32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstU32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32U32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32U32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32U32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolU32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullU32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarBoolToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegBoolToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccBoolToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackBoolToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstBoolToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32BoolToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32BoolToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32BoolToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolBoolToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullBoolToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarNullToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegNullToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccNullToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackNullToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstNullToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32NullToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32NullToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32NullToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolNullToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullNullToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedNullToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarUndefinedToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegUndefinedToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccUndefinedToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackUndefinedToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstUndefinedToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32UndefinedToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32UndefinedToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32UndefinedToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullUndefinedToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarVarToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegVarToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccVarToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackVarToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstVarToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32VarToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32VarToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32VarToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolVarToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullVarToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedVarToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarRegToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegRegToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccRegToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackRegToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstRegToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32RegToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32RegToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32RegToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolRegToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullRegToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedRegToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarAccToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegAccToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccAccToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackAccToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstAccToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32AccToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32AccToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32AccToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolAccToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullAccToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedAccToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarStackToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegStackToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccStackToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackStackToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstStackToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32StackToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32StackToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32StackToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolStackToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullStackToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedStackToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarConstToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegConstToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccConstToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackConstToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstConstToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32ConstToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32ConstToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32ConstToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolConstToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullConstToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedConstToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarF32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegF32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccF32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackF32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstF32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32F32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32F32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32F32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolF32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullF32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarI32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegI32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccI32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackI32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstI32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32I32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32I32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32I32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolI32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullI32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarU32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegU32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccU32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackU32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstU32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32U32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32U32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32U32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolU32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullU32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarBoolToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegBoolToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccBoolToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackBoolToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstBoolToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32BoolToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32BoolToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32BoolToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolBoolToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullBoolToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarNullToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegNullToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccNullToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackNullToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstNullToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32NullToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32NullToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32NullToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolNullToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullNullToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedNullToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarUndefinedToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegUndefinedToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccUndefinedToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackUndefinedToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstUndefinedToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32UndefinedToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32UndefinedToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32UndefinedToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullUndefinedToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarVarToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegVarToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccVarToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackVarToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstVarToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32VarToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32VarToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32VarToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolVarToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullVarToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarRegToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegRegToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccRegToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackRegToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstRegToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32RegToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32RegToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32RegToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolRegToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullRegToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarAccToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegAccToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccAccToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackAccToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstAccToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32AccToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32AccToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32AccToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolAccToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullAccToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarStackToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegStackToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccStackToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackStackToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstStackToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32StackToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32StackToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32StackToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolStackToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullStackToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarConstToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegConstToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccConstToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackConstToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstConstToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32ConstToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32ConstToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32ConstToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolConstToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullConstToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarF32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegF32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccF32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackF32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstF32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32F32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32F32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32F32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolF32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullF32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarI32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegI32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccI32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackI32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstI32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32I32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32I32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32I32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolI32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullI32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarU32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegU32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccU32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackU32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstU32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32U32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32U32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32U32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolU32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullU32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarBoolToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegBoolToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccBoolToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackBoolToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstBoolToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32BoolToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32BoolToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32BoolToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolBoolToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullBoolToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarNullToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegNullToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccNullToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackNullToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstNullToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32NullToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32NullToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32NullToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolNullToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullNullToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarVarToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegVarToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccVarToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackVarToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstVarToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32VarToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32VarToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32VarToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolVarToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullVarToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedVarToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarRegToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegRegToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccRegToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackRegToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstRegToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32RegToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32RegToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32RegToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolRegToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullRegToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedRegToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarAccToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegAccToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccAccToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackAccToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstAccToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32AccToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32AccToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32AccToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolAccToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullAccToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedAccToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarStackToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegStackToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccStackToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackStackToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstStackToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32StackToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32StackToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32StackToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolStackToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullStackToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedStackToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarConstToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegConstToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccConstToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackConstToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstConstToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32ConstToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32ConstToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32ConstToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolConstToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullConstToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedConstToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarF32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegF32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccF32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackF32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstF32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32F32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32F32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32F32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolF32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullF32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarI32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegI32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccI32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackI32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstI32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32I32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32I32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32I32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolI32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullI32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarU32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegU32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccU32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackU32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstU32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32U32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32U32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32U32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolU32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullU32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarBoolToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegBoolToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccBoolToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackBoolToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstBoolToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32BoolToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32BoolToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32BoolToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolBoolToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullBoolToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarNullToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegNullToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccNullToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackNullToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstNullToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32NullToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32NullToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32NullToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolNullToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullNullToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedNullToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeVarUndefinedToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeRegUndefinedToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeAccUndefinedToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeStackUndefinedToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeConstUndefinedToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeF32UndefinedToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeI32UndefinedToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeU32UndefinedToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeNullUndefinedToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::NeUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::ne(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarVarToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegVarToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccVarToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackVarToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstVarToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32VarToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32VarToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32VarToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolVarToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullVarToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedVarToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarRegToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegRegToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccRegToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackRegToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstRegToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32RegToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32RegToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32RegToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolRegToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullRegToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedRegToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarAccToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegAccToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccAccToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackAccToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstAccToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32AccToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32AccToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32AccToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolAccToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullAccToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedAccToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarStackToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegStackToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccStackToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackStackToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstStackToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32StackToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32StackToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32StackToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolStackToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullStackToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedStackToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarConstToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegConstToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccConstToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackConstToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstConstToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32ConstToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32ConstToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32ConstToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolConstToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullConstToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedConstToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarF32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegF32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccF32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackF32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstF32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32F32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32F32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32F32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolF32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullF32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarI32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegI32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccI32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackI32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstI32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32I32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32I32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32I32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolI32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullI32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarU32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegU32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccU32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackU32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstU32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32U32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32U32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32U32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolU32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullU32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarBoolToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegBoolToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccBoolToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackBoolToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstBoolToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32BoolToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32BoolToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32BoolToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolBoolToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullBoolToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarNullToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegNullToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccNullToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackNullToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstNullToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32NullToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32NullToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32NullToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolNullToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullNullToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedNullToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32UndefinedToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32UndefinedToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32UndefinedToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarVarToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegVarToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccVarToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackVarToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstVarToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32VarToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32VarToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32VarToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolVarToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullVarToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedVarToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarRegToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegRegToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccRegToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackRegToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstRegToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32RegToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32RegToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32RegToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolRegToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullRegToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedRegToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarAccToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegAccToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccAccToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackAccToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstAccToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32AccToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32AccToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32AccToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolAccToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullAccToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedAccToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarStackToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegStackToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccStackToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackStackToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstStackToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32StackToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32StackToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32StackToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolStackToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullStackToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedStackToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarConstToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegConstToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccConstToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackConstToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstConstToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32ConstToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32ConstToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32ConstToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolConstToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullConstToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedConstToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarF32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegF32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccF32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackF32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstF32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32F32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32F32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32F32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolF32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullF32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarI32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegI32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccI32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackI32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstI32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32I32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32I32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32I32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolI32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullI32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarU32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegU32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccU32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackU32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstU32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32U32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32U32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32U32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolU32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullU32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarBoolToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegBoolToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccBoolToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackBoolToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstBoolToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32BoolToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32BoolToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32BoolToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolBoolToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullBoolToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarNullToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegNullToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccNullToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackNullToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstNullToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32NullToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32NullToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32NullToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolNullToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullNullToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedNullToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32UndefinedToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32UndefinedToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32UndefinedToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarVarToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegVarToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccVarToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackVarToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstVarToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32VarToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32VarToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32VarToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolVarToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullVarToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarRegToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegRegToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccRegToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackRegToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstRegToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32RegToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32RegToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32RegToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolRegToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullRegToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarAccToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegAccToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccAccToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackAccToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstAccToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32AccToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32AccToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32AccToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolAccToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullAccToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarStackToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegStackToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccStackToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackStackToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstStackToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32StackToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32StackToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32StackToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolStackToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullStackToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarConstToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegConstToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccConstToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackConstToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstConstToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32ConstToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32ConstToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32ConstToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolConstToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullConstToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarF32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegF32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccF32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackF32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstF32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32F32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32F32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32F32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolF32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullF32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarI32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegI32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccI32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackI32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstI32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32I32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32I32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32I32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolI32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullI32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarU32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegU32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccU32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackU32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstU32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32U32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32U32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32U32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolU32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullU32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarBoolToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegBoolToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccBoolToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackBoolToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstBoolToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32BoolToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32BoolToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32BoolToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolBoolToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullBoolToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarNullToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegNullToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccNullToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackNullToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstNullToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32NullToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32NullToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32NullToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolNullToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullNullToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarVarToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegVarToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccVarToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackVarToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstVarToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32VarToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32VarToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32VarToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolVarToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullVarToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedVarToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarRegToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegRegToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccRegToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackRegToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstRegToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32RegToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32RegToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32RegToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolRegToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullRegToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedRegToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarAccToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegAccToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccAccToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackAccToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstAccToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32AccToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32AccToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32AccToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolAccToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullAccToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedAccToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarStackToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegStackToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccStackToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackStackToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstStackToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32StackToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32StackToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32StackToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolStackToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullStackToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedStackToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarConstToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegConstToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccConstToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackConstToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstConstToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32ConstToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32ConstToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32ConstToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolConstToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullConstToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedConstToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarF32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegF32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccF32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackF32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstF32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32F32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32F32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32F32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolF32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullF32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarI32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegI32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccI32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackI32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstI32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32I32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32I32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32I32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolI32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullI32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarU32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegU32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccU32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackU32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstU32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32U32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32U32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32U32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolU32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullU32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarBoolToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegBoolToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccBoolToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackBoolToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstBoolToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32BoolToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32BoolToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32BoolToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolBoolToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullBoolToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarNullToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegNullToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccNullToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackNullToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstNullToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32NullToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32NullToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32NullToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolNullToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullNullToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedNullToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqVarUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqRegUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqAccUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqStackUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqConstUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqF32UndefinedToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqI32UndefinedToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqU32UndefinedToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqNullUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictEqUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarVarToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegVarToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccVarToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackVarToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstVarToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32VarToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32VarToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32VarToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolVarToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullVarToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedVarToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarRegToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegRegToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccRegToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackRegToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstRegToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32RegToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32RegToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32RegToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolRegToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullRegToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedRegToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarAccToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegAccToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccAccToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackAccToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstAccToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32AccToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32AccToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32AccToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolAccToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullAccToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedAccToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarStackToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegStackToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccStackToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackStackToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstStackToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32StackToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32StackToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32StackToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolStackToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullStackToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedStackToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarConstToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegConstToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccConstToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackConstToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstConstToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32ConstToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32ConstToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32ConstToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolConstToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullConstToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedConstToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarF32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegF32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccF32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackF32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstF32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32F32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32F32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32F32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolF32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullF32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarI32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegI32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccI32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackI32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstI32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32I32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32I32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32I32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolI32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullI32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarU32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegU32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccU32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackU32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstU32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32U32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32U32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32U32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolU32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullU32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarBoolToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegBoolToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccBoolToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackBoolToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstBoolToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32BoolToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32BoolToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32BoolToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolBoolToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullBoolToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarNullToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegNullToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccNullToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackNullToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstNullToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32NullToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32NullToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32NullToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolNullToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullNullToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedNullToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32UndefinedToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32UndefinedToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32UndefinedToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarVarToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegVarToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccVarToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackVarToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstVarToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32VarToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32VarToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32VarToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolVarToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullVarToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedVarToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarRegToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegRegToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccRegToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackRegToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstRegToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32RegToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32RegToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32RegToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolRegToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullRegToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedRegToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarAccToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegAccToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccAccToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackAccToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstAccToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32AccToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32AccToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32AccToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolAccToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullAccToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedAccToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarStackToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegStackToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccStackToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackStackToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstStackToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32StackToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32StackToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32StackToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolStackToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullStackToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedStackToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarConstToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegConstToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccConstToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackConstToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstConstToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32ConstToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32ConstToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32ConstToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolConstToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullConstToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedConstToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarF32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegF32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccF32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackF32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstF32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32F32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32F32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32F32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolF32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullF32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarI32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegI32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccI32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackI32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstI32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32I32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32I32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32I32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolI32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullI32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarU32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegU32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccU32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackU32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstU32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32U32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32U32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32U32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolU32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullU32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarBoolToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegBoolToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccBoolToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackBoolToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstBoolToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32BoolToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32BoolToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32BoolToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolBoolToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullBoolToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarNullToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegNullToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccNullToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackNullToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstNullToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32NullToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32NullToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32NullToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolNullToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullNullToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedNullToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32UndefinedToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32UndefinedToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32UndefinedToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarVarToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegVarToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccVarToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackVarToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstVarToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32VarToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32VarToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32VarToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolVarToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullVarToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarRegToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegRegToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccRegToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackRegToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstRegToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32RegToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32RegToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32RegToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolRegToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullRegToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarAccToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegAccToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccAccToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackAccToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstAccToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32AccToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32AccToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32AccToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolAccToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullAccToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarStackToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegStackToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccStackToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackStackToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstStackToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32StackToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32StackToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32StackToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolStackToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullStackToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarConstToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegConstToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccConstToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackConstToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstConstToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32ConstToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32ConstToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32ConstToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolConstToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullConstToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarF32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegF32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccF32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackF32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstF32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32F32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32F32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32F32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolF32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullF32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarI32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegI32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccI32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackI32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstI32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32I32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32I32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32I32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolI32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullI32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarU32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegU32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccU32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackU32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstU32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32U32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32U32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32U32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolU32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullU32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarBoolToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegBoolToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccBoolToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackBoolToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstBoolToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32BoolToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32BoolToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32BoolToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolBoolToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullBoolToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarNullToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegNullToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccNullToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackNullToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstNullToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32NullToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32NullToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32NullToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolNullToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullNullToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarVarToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegVarToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccVarToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackVarToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstVarToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32VarToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32VarToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32VarToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolVarToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullVarToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedVarToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarRegToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegRegToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccRegToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackRegToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstRegToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32RegToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32RegToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32RegToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolRegToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullRegToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedRegToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarAccToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegAccToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccAccToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackAccToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstAccToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32AccToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32AccToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32AccToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolAccToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullAccToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedAccToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarStackToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegStackToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccStackToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackStackToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstStackToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32StackToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32StackToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32StackToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolStackToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullStackToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedStackToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarConstToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegConstToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccConstToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackConstToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstConstToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32ConstToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32ConstToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32ConstToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolConstToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullConstToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedConstToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarF32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegF32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccF32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackF32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstF32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32F32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32F32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32F32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolF32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullF32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarI32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegI32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccI32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackI32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstI32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32I32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32I32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32I32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolI32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullI32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarU32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegU32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccU32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackU32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstU32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32U32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32U32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32U32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolU32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullU32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarBoolToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegBoolToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccBoolToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackBoolToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstBoolToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32BoolToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32BoolToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32BoolToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolBoolToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullBoolToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarNullToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegNullToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccNullToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackNullToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstNullToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32NullToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32NullToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32NullToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolNullToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullNullToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedNullToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeVarUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeRegUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeAccUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeStackUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeConstUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeF32UndefinedToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeI32UndefinedToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeU32UndefinedToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeNullUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::StrictNeUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::LtVarVarToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegVarToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccVarToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackVarToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstVarToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32VarToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32VarToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32VarToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolVarToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullVarToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedVarToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarRegToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegRegToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccRegToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackRegToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstRegToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32RegToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32RegToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32RegToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolRegToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullRegToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedRegToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarAccToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegAccToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccAccToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackAccToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstAccToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32AccToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32AccToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32AccToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolAccToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullAccToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedAccToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarStackToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegStackToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccStackToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackStackToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstStackToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32StackToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32StackToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32StackToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolStackToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullStackToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedStackToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarConstToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegConstToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccConstToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackConstToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstConstToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32ConstToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32ConstToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32ConstToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolConstToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullConstToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedConstToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarF32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegF32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccF32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackF32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstF32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32F32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32F32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32F32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolF32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullF32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarI32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegI32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccI32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackI32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstI32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32I32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32I32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32I32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolI32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullI32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarU32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegU32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccU32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackU32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstU32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32U32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32U32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32U32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolU32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullU32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarBoolToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegBoolToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccBoolToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackBoolToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstBoolToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32BoolToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32BoolToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32BoolToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolBoolToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullBoolToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarNullToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegNullToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccNullToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackNullToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstNullToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32NullToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32NullToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32NullToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolNullToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullNullToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedNullToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarUndefinedToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegUndefinedToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccUndefinedToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackUndefinedToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstUndefinedToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32UndefinedToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32UndefinedToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32UndefinedToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullUndefinedToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarVarToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegVarToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccVarToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackVarToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstVarToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32VarToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32VarToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32VarToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolVarToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullVarToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedVarToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarRegToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegRegToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccRegToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackRegToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstRegToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32RegToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32RegToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32RegToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolRegToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullRegToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedRegToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarAccToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegAccToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccAccToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackAccToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstAccToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32AccToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32AccToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32AccToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolAccToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullAccToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedAccToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarStackToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegStackToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccStackToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackStackToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstStackToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32StackToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32StackToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32StackToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolStackToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullStackToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedStackToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarConstToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegConstToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccConstToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackConstToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstConstToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32ConstToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32ConstToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32ConstToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolConstToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullConstToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedConstToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarF32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegF32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccF32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackF32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstF32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32F32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32F32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32F32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolF32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullF32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarI32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegI32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccI32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackI32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstI32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32I32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32I32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32I32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolI32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullI32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarU32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegU32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccU32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackU32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstU32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32U32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32U32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32U32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolU32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullU32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarBoolToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegBoolToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccBoolToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackBoolToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstBoolToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32BoolToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32BoolToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32BoolToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolBoolToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullBoolToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarNullToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegNullToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccNullToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackNullToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstNullToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32NullToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32NullToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32NullToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolNullToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullNullToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedNullToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarUndefinedToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegUndefinedToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccUndefinedToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackUndefinedToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstUndefinedToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32UndefinedToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32UndefinedToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32UndefinedToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullUndefinedToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarVarToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegVarToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccVarToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackVarToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstVarToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32VarToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32VarToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32VarToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolVarToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullVarToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarRegToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegRegToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccRegToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackRegToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstRegToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32RegToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32RegToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32RegToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolRegToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullRegToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarAccToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegAccToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccAccToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackAccToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstAccToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32AccToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32AccToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32AccToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolAccToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullAccToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarStackToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegStackToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccStackToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackStackToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstStackToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32StackToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32StackToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32StackToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolStackToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullStackToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarConstToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegConstToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccConstToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackConstToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstConstToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32ConstToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32ConstToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32ConstToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolConstToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullConstToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarF32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegF32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccF32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackF32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstF32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32F32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32F32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32F32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolF32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullF32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarI32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegI32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccI32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackI32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstI32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32I32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32I32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32I32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolI32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullI32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarU32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegU32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccU32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackU32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstU32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32U32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32U32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32U32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolU32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullU32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarBoolToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegBoolToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccBoolToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackBoolToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstBoolToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32BoolToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32BoolToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32BoolToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolBoolToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullBoolToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarNullToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegNullToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccNullToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackNullToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstNullToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32NullToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32NullToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32NullToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolNullToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullNullToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarVarToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegVarToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccVarToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackVarToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstVarToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32VarToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32VarToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32VarToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolVarToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullVarToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedVarToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarRegToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegRegToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccRegToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackRegToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstRegToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32RegToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32RegToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32RegToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolRegToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullRegToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedRegToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarAccToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegAccToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccAccToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackAccToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstAccToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32AccToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32AccToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32AccToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolAccToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullAccToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedAccToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarStackToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegStackToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccStackToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackStackToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstStackToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32StackToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32StackToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32StackToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolStackToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullStackToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedStackToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarConstToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegConstToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccConstToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackConstToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstConstToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32ConstToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32ConstToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32ConstToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolConstToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullConstToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedConstToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarF32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegF32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccF32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackF32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstF32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32F32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32F32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32F32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolF32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullF32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarI32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegI32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccI32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackI32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstI32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32I32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32I32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32I32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolI32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullI32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarU32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegU32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccU32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackU32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstU32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32U32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32U32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32U32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolU32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullU32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarBoolToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegBoolToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccBoolToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackBoolToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstBoolToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32BoolToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32BoolToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32BoolToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolBoolToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullBoolToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarNullToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegNullToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccNullToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackNullToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstNullToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32NullToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32NullToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32NullToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolNullToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullNullToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedNullToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtVarUndefinedToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtRegUndefinedToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtAccUndefinedToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtStackUndefinedToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtConstUndefinedToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtF32UndefinedToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtI32UndefinedToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtU32UndefinedToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtNullUndefinedToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::lt(arg0, arg1, output, vm)?
            }
            Self::LtEqVarVarToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegVarToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccVarToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackVarToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstVarToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32VarToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32VarToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32VarToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolVarToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullVarToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedVarToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarRegToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegRegToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccRegToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackRegToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstRegToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32RegToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32RegToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32RegToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolRegToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullRegToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedRegToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarAccToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegAccToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccAccToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackAccToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstAccToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32AccToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32AccToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32AccToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolAccToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullAccToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedAccToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarStackToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegStackToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccStackToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackStackToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstStackToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32StackToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32StackToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32StackToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolStackToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullStackToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedStackToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarConstToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegConstToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccConstToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackConstToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstConstToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32ConstToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32ConstToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32ConstToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolConstToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullConstToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedConstToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarF32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegF32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccF32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackF32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstF32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32F32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32F32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32F32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolF32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullF32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarI32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegI32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccI32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackI32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstI32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32I32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32I32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32I32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolI32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullI32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarU32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegU32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccU32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackU32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstU32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32U32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32U32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32U32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolU32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullU32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarBoolToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegBoolToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccBoolToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackBoolToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstBoolToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32BoolToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32BoolToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32BoolToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolBoolToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullBoolToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarNullToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegNullToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccNullToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackNullToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstNullToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32NullToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32NullToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32NullToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolNullToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullNullToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedNullToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarUndefinedToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegUndefinedToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccUndefinedToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackUndefinedToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstUndefinedToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32UndefinedToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32UndefinedToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32UndefinedToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullUndefinedToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarVarToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegVarToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccVarToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackVarToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstVarToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32VarToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32VarToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32VarToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolVarToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullVarToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedVarToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarRegToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegRegToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccRegToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackRegToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstRegToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32RegToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32RegToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32RegToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolRegToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullRegToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedRegToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarAccToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegAccToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccAccToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackAccToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstAccToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32AccToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32AccToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32AccToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolAccToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullAccToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedAccToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarStackToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegStackToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccStackToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackStackToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstStackToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32StackToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32StackToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32StackToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolStackToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullStackToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedStackToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarConstToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegConstToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccConstToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackConstToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstConstToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32ConstToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32ConstToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32ConstToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolConstToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullConstToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedConstToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarF32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegF32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccF32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackF32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstF32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32F32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32F32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32F32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolF32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullF32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarI32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegI32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccI32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackI32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstI32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32I32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32I32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32I32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolI32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullI32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarU32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegU32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccU32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackU32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstU32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32U32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32U32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32U32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolU32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullU32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarBoolToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegBoolToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccBoolToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackBoolToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstBoolToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32BoolToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32BoolToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32BoolToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolBoolToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullBoolToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarNullToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegNullToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccNullToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackNullToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstNullToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32NullToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32NullToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32NullToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolNullToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullNullToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedNullToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarUndefinedToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegUndefinedToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccUndefinedToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackUndefinedToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstUndefinedToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32UndefinedToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32UndefinedToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32UndefinedToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullUndefinedToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarVarToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegVarToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccVarToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackVarToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstVarToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32VarToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32VarToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32VarToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolVarToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullVarToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarRegToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegRegToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccRegToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackRegToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstRegToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32RegToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32RegToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32RegToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolRegToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullRegToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarAccToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegAccToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccAccToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackAccToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstAccToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32AccToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32AccToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32AccToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolAccToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullAccToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarStackToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegStackToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccStackToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackStackToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstStackToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32StackToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32StackToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32StackToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolStackToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullStackToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarConstToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegConstToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccConstToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackConstToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstConstToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32ConstToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32ConstToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32ConstToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolConstToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullConstToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarF32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegF32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccF32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackF32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstF32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32F32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32F32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32F32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolF32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullF32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarI32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegI32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccI32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackI32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstI32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32I32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32I32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32I32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolI32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullI32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarU32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegU32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccU32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackU32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstU32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32U32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32U32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32U32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolU32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullU32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarBoolToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegBoolToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccBoolToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackBoolToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstBoolToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32BoolToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32BoolToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32BoolToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolBoolToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullBoolToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarNullToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegNullToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccNullToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackNullToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstNullToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32NullToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32NullToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32NullToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolNullToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullNullToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarVarToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegVarToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccVarToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackVarToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstVarToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32VarToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32VarToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32VarToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolVarToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullVarToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedVarToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarRegToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegRegToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccRegToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackRegToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstRegToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32RegToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32RegToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32RegToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolRegToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullRegToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedRegToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarAccToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegAccToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccAccToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackAccToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstAccToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32AccToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32AccToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32AccToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolAccToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullAccToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedAccToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarStackToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegStackToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccStackToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackStackToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstStackToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32StackToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32StackToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32StackToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolStackToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullStackToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedStackToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarConstToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegConstToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccConstToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackConstToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstConstToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32ConstToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32ConstToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32ConstToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolConstToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullConstToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedConstToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarF32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegF32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccF32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackF32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstF32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32F32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32F32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32F32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolF32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullF32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarI32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegI32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccI32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackI32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstI32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32I32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32I32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32I32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolI32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullI32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarU32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegU32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccU32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackU32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstU32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32U32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32U32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32U32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolU32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullU32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarBoolToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegBoolToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccBoolToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackBoolToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstBoolToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32BoolToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32BoolToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32BoolToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolBoolToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullBoolToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarNullToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegNullToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccNullToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackNullToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstNullToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32NullToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32NullToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32NullToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolNullToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullNullToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedNullToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqVarUndefinedToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqRegUndefinedToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqAccUndefinedToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqStackUndefinedToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqConstUndefinedToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqF32UndefinedToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqI32UndefinedToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqU32UndefinedToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqNullUndefinedToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::LtEqUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::lt_eq(arg0, arg1, output, vm)?
            }
            Self::GtVarVarToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegVarToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccVarToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackVarToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstVarToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32VarToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32VarToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32VarToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolVarToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullVarToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedVarToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarRegToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegRegToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccRegToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackRegToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstRegToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32RegToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32RegToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32RegToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolRegToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullRegToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedRegToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarAccToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegAccToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccAccToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackAccToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstAccToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32AccToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32AccToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32AccToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolAccToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullAccToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedAccToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarStackToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegStackToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccStackToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackStackToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstStackToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32StackToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32StackToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32StackToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolStackToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullStackToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedStackToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarConstToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegConstToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccConstToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackConstToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstConstToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32ConstToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32ConstToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32ConstToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolConstToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullConstToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedConstToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarF32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegF32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccF32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackF32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstF32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32F32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32F32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32F32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolF32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullF32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarI32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegI32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccI32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackI32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstI32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32I32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32I32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32I32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolI32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullI32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarU32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegU32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccU32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackU32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstU32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32U32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32U32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32U32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolU32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullU32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarBoolToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegBoolToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccBoolToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackBoolToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstBoolToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32BoolToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32BoolToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32BoolToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolBoolToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullBoolToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarNullToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegNullToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccNullToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackNullToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstNullToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32NullToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32NullToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32NullToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolNullToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullNullToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedNullToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarUndefinedToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegUndefinedToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccUndefinedToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackUndefinedToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstUndefinedToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32UndefinedToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32UndefinedToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32UndefinedToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullUndefinedToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarVarToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegVarToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccVarToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackVarToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstVarToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32VarToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32VarToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32VarToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolVarToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullVarToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedVarToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarRegToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegRegToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccRegToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackRegToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstRegToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32RegToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32RegToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32RegToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolRegToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullRegToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedRegToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarAccToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegAccToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccAccToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackAccToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstAccToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32AccToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32AccToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32AccToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolAccToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullAccToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedAccToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarStackToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegStackToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccStackToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackStackToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstStackToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32StackToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32StackToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32StackToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolStackToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullStackToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedStackToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarConstToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegConstToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccConstToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackConstToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstConstToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32ConstToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32ConstToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32ConstToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolConstToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullConstToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedConstToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarF32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegF32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccF32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackF32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstF32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32F32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32F32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32F32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolF32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullF32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarI32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegI32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccI32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackI32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstI32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32I32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32I32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32I32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolI32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullI32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarU32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegU32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccU32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackU32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstU32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32U32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32U32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32U32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolU32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullU32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarBoolToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegBoolToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccBoolToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackBoolToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstBoolToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32BoolToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32BoolToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32BoolToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolBoolToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullBoolToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarNullToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegNullToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccNullToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackNullToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstNullToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32NullToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32NullToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32NullToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolNullToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullNullToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedNullToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarUndefinedToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegUndefinedToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccUndefinedToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackUndefinedToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstUndefinedToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32UndefinedToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32UndefinedToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32UndefinedToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullUndefinedToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarVarToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegVarToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccVarToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackVarToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstVarToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32VarToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32VarToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32VarToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolVarToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullVarToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarRegToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegRegToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccRegToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackRegToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstRegToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32RegToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32RegToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32RegToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolRegToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullRegToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarAccToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegAccToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccAccToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackAccToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstAccToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32AccToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32AccToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32AccToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolAccToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullAccToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarStackToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegStackToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccStackToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackStackToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstStackToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32StackToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32StackToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32StackToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolStackToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullStackToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarConstToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegConstToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccConstToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackConstToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstConstToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32ConstToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32ConstToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32ConstToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolConstToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullConstToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarF32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegF32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccF32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackF32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstF32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32F32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32F32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32F32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolF32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullF32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarI32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegI32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccI32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackI32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstI32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32I32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32I32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32I32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolI32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullI32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarU32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegU32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccU32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackU32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstU32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32U32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32U32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32U32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolU32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullU32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarBoolToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegBoolToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccBoolToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackBoolToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstBoolToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32BoolToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32BoolToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32BoolToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolBoolToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullBoolToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarNullToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegNullToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccNullToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackNullToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstNullToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32NullToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32NullToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32NullToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolNullToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullNullToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarVarToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegVarToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccVarToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackVarToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstVarToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32VarToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32VarToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32VarToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolVarToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullVarToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedVarToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarRegToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegRegToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccRegToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackRegToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstRegToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32RegToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32RegToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32RegToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolRegToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullRegToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedRegToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarAccToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegAccToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccAccToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackAccToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstAccToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32AccToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32AccToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32AccToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolAccToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullAccToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedAccToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarStackToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegStackToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccStackToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackStackToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstStackToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32StackToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32StackToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32StackToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolStackToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullStackToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedStackToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarConstToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegConstToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccConstToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackConstToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstConstToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32ConstToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32ConstToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32ConstToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolConstToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullConstToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedConstToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarF32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegF32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccF32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackF32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstF32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32F32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32F32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32F32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolF32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullF32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarI32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegI32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccI32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackI32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstI32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32I32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32I32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32I32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolI32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullI32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarU32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegU32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccU32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackU32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstU32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32U32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32U32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32U32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolU32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullU32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarBoolToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegBoolToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccBoolToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackBoolToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstBoolToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32BoolToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32BoolToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32BoolToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolBoolToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullBoolToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarNullToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegNullToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccNullToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackNullToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstNullToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32NullToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32NullToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32NullToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolNullToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullNullToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedNullToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtVarUndefinedToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtRegUndefinedToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtAccUndefinedToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtStackUndefinedToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtConstUndefinedToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtF32UndefinedToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtI32UndefinedToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtU32UndefinedToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtNullUndefinedToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::gt(arg0, arg1, output, vm)?
            }
            Self::GtEqVarVarToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegVarToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccVarToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackVarToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstVarToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32VarToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32VarToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32VarToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolVarToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullVarToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedVarToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarRegToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegRegToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccRegToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackRegToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstRegToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32RegToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32RegToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32RegToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolRegToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullRegToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedRegToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarAccToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegAccToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccAccToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackAccToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstAccToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32AccToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32AccToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32AccToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolAccToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullAccToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedAccToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarStackToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegStackToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccStackToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackStackToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstStackToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32StackToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32StackToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32StackToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolStackToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullStackToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedStackToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarConstToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegConstToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccConstToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackConstToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstConstToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32ConstToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32ConstToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32ConstToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolConstToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullConstToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedConstToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarF32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegF32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccF32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackF32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstF32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32F32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32F32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32F32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolF32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullF32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarI32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegI32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccI32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackI32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstI32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32I32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32I32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32I32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolI32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullI32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarU32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegU32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccU32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackU32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstU32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32U32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32U32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32U32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolU32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullU32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarBoolToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegBoolToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccBoolToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackBoolToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstBoolToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32BoolToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32BoolToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32BoolToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolBoolToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullBoolToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarNullToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegNullToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccNullToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackNullToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstNullToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32NullToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32NullToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32NullToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolNullToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullNullToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedNullToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarUndefinedToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegUndefinedToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccUndefinedToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackUndefinedToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstUndefinedToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32UndefinedToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32UndefinedToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32UndefinedToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullUndefinedToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarVarToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegVarToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccVarToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackVarToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstVarToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32VarToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32VarToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32VarToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolVarToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullVarToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedVarToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarRegToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegRegToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccRegToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackRegToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstRegToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32RegToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32RegToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32RegToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolRegToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullRegToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedRegToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarAccToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegAccToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccAccToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackAccToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstAccToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32AccToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32AccToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32AccToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolAccToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullAccToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedAccToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarStackToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegStackToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccStackToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackStackToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstStackToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32StackToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32StackToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32StackToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolStackToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullStackToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedStackToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarConstToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegConstToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccConstToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackConstToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstConstToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32ConstToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32ConstToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32ConstToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolConstToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullConstToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedConstToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarF32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegF32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccF32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackF32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstF32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32F32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32F32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32F32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolF32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullF32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarI32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegI32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccI32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackI32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstI32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32I32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32I32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32I32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolI32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullI32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarU32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegU32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccU32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackU32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstU32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32U32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32U32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32U32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolU32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullU32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarBoolToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegBoolToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccBoolToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackBoolToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstBoolToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32BoolToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32BoolToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32BoolToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolBoolToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullBoolToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarNullToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegNullToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccNullToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackNullToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstNullToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32NullToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32NullToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32NullToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolNullToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullNullToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedNullToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarUndefinedToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegUndefinedToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccUndefinedToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackUndefinedToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstUndefinedToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32UndefinedToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32UndefinedToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32UndefinedToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullUndefinedToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarVarToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegVarToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccVarToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackVarToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstVarToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32VarToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32VarToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32VarToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolVarToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullVarToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarRegToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegRegToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccRegToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackRegToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstRegToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32RegToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32RegToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32RegToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolRegToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullRegToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarAccToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegAccToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccAccToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackAccToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstAccToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32AccToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32AccToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32AccToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolAccToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullAccToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarStackToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegStackToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccStackToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackStackToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstStackToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32StackToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32StackToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32StackToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolStackToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullStackToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarConstToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegConstToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccConstToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackConstToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstConstToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32ConstToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32ConstToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32ConstToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolConstToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullConstToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarF32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegF32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccF32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackF32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstF32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32F32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32F32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32F32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolF32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullF32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarI32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegI32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccI32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackI32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstI32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32I32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32I32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32I32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolI32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullI32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarU32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegU32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccU32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackU32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstU32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32U32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32U32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32U32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolU32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullU32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarBoolToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegBoolToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccBoolToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackBoolToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstBoolToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32BoolToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32BoolToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32BoolToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolBoolToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullBoolToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarNullToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegNullToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccNullToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackNullToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstNullToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32NullToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32NullToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32NullToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolNullToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullNullToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarVarToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegVarToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccVarToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackVarToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstVarToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32VarToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32VarToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32VarToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolVarToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullVarToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedVarToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarRegToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegRegToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccRegToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackRegToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstRegToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32RegToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32RegToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32RegToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolRegToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullRegToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedRegToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarAccToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegAccToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccAccToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackAccToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstAccToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32AccToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32AccToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32AccToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolAccToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullAccToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedAccToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarStackToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegStackToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccStackToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackStackToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstStackToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32StackToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32StackToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32StackToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolStackToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullStackToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedStackToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarConstToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegConstToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccConstToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackConstToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstConstToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32ConstToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32ConstToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32ConstToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolConstToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullConstToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedConstToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarF32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegF32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccF32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackF32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstF32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32F32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32F32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32F32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolF32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullF32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarI32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegI32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccI32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackI32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstI32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32I32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32I32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32I32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolI32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullI32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarU32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegU32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccU32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackU32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstU32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32U32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32U32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32U32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolU32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullU32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarBoolToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegBoolToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccBoolToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackBoolToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstBoolToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32BoolToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32BoolToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32BoolToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolBoolToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullBoolToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarNullToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegNullToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccNullToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackNullToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstNullToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32NullToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32NullToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32NullToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolNullToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullNullToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedNullToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqVarUndefinedToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqRegUndefinedToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqAccUndefinedToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqStackUndefinedToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqConstUndefinedToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqF32UndefinedToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqI32UndefinedToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqU32UndefinedToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqNullUndefinedToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::GtEqUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::gt_eq(arg0, arg1, output, vm)?
            }
            Self::LShiftVarVarToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegVarToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccVarToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackVarToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstVarToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32VarToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32VarToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32VarToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolVarToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullVarToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedVarToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarRegToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegRegToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccRegToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackRegToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstRegToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32RegToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32RegToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32RegToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolRegToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullRegToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedRegToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarAccToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegAccToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccAccToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackAccToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstAccToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32AccToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32AccToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32AccToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolAccToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullAccToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedAccToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarStackToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegStackToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccStackToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackStackToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstStackToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32StackToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32StackToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32StackToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolStackToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullStackToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedStackToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarConstToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegConstToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccConstToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackConstToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstConstToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32ConstToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32ConstToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32ConstToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolConstToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullConstToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedConstToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarF32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegF32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccF32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackF32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstF32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32F32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32F32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32F32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolF32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullF32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarI32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegI32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccI32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackI32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstI32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32I32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32I32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32I32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolI32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullI32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarU32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegU32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccU32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackU32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstU32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32U32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32U32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32U32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolU32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullU32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarBoolToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegBoolToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccBoolToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackBoolToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstBoolToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32BoolToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32BoolToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32BoolToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolBoolToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullBoolToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarNullToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegNullToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccNullToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackNullToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstNullToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32NullToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32NullToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32NullToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolNullToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullNullToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedNullToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarUndefinedToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegUndefinedToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccUndefinedToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackUndefinedToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstUndefinedToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32UndefinedToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32UndefinedToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32UndefinedToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullUndefinedToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarVarToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegVarToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccVarToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackVarToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstVarToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32VarToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32VarToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32VarToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolVarToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullVarToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedVarToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarRegToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegRegToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccRegToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackRegToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstRegToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32RegToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32RegToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32RegToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolRegToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullRegToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedRegToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarAccToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegAccToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccAccToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackAccToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstAccToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32AccToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32AccToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32AccToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolAccToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullAccToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedAccToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarStackToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegStackToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccStackToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackStackToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstStackToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32StackToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32StackToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32StackToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolStackToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullStackToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedStackToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarConstToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegConstToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccConstToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackConstToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstConstToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32ConstToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32ConstToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32ConstToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolConstToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullConstToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedConstToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarF32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegF32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccF32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackF32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstF32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32F32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32F32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32F32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolF32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullF32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarI32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegI32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccI32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackI32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstI32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32I32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32I32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32I32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolI32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullI32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarU32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegU32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccU32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackU32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstU32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32U32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32U32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32U32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolU32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullU32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarBoolToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegBoolToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccBoolToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackBoolToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstBoolToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32BoolToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32BoolToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32BoolToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolBoolToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullBoolToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarNullToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegNullToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccNullToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackNullToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstNullToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32NullToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32NullToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32NullToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolNullToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullNullToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedNullToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarUndefinedToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegUndefinedToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccUndefinedToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackUndefinedToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstUndefinedToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32UndefinedToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32UndefinedToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32UndefinedToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullUndefinedToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarVarToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegVarToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccVarToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackVarToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstVarToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32VarToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32VarToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32VarToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolVarToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullVarToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarRegToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegRegToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccRegToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackRegToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstRegToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32RegToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32RegToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32RegToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolRegToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullRegToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarAccToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegAccToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccAccToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackAccToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstAccToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32AccToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32AccToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32AccToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolAccToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullAccToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarStackToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegStackToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccStackToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackStackToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstStackToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32StackToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32StackToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32StackToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolStackToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullStackToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarConstToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegConstToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccConstToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackConstToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstConstToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32ConstToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32ConstToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32ConstToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolConstToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullConstToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarF32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegF32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccF32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackF32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstF32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32F32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32F32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32F32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolF32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullF32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarI32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegI32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccI32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackI32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstI32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32I32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32I32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32I32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolI32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullI32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarU32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegU32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccU32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackU32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstU32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32U32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32U32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32U32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolU32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullU32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarBoolToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegBoolToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccBoolToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackBoolToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstBoolToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32BoolToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32BoolToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32BoolToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolBoolToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullBoolToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarNullToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegNullToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccNullToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackNullToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstNullToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32NullToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32NullToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32NullToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolNullToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullNullToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarVarToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegVarToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccVarToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackVarToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstVarToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32VarToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32VarToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32VarToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolVarToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullVarToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedVarToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarRegToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegRegToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccRegToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackRegToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstRegToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32RegToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32RegToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32RegToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolRegToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullRegToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedRegToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarAccToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegAccToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccAccToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackAccToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstAccToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32AccToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32AccToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32AccToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolAccToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullAccToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedAccToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarStackToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegStackToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccStackToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackStackToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstStackToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32StackToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32StackToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32StackToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolStackToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullStackToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedStackToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarConstToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegConstToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccConstToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackConstToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstConstToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32ConstToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32ConstToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32ConstToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolConstToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullConstToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedConstToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarF32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegF32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccF32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackF32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstF32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32F32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32F32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32F32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolF32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullF32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarI32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegI32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccI32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackI32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstI32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32I32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32I32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32I32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolI32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullI32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarU32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegU32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccU32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackU32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstU32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32U32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32U32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32U32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolU32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullU32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarBoolToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegBoolToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccBoolToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackBoolToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstBoolToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32BoolToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32BoolToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32BoolToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolBoolToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullBoolToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarNullToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegNullToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccNullToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackNullToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstNullToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32NullToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32NullToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32NullToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolNullToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullNullToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedNullToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftVarUndefinedToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftRegUndefinedToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftAccUndefinedToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftStackUndefinedToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftConstUndefinedToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftF32UndefinedToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftI32UndefinedToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftU32UndefinedToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftNullUndefinedToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::LShiftUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarVarToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegVarToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccVarToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackVarToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstVarToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32VarToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32VarToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32VarToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolVarToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullVarToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedVarToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarRegToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegRegToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccRegToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackRegToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstRegToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32RegToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32RegToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32RegToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolRegToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullRegToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedRegToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarAccToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegAccToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccAccToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackAccToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstAccToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32AccToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32AccToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32AccToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolAccToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullAccToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedAccToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarStackToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegStackToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccStackToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackStackToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstStackToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32StackToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32StackToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32StackToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolStackToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullStackToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedStackToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarConstToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegConstToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccConstToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackConstToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstConstToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32ConstToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32ConstToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32ConstToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolConstToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullConstToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedConstToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarF32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegF32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccF32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackF32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstF32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32F32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32F32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32F32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolF32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullF32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarI32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegI32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccI32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackI32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstI32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32I32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32I32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32I32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolI32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullI32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarU32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegU32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccU32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackU32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstU32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32U32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32U32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32U32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolU32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullU32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarBoolToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegBoolToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccBoolToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackBoolToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstBoolToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32BoolToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32BoolToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32BoolToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolBoolToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullBoolToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarNullToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegNullToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccNullToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackNullToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstNullToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32NullToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32NullToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32NullToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolNullToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullNullToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedNullToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarUndefinedToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegUndefinedToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccUndefinedToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackUndefinedToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstUndefinedToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32UndefinedToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32UndefinedToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32UndefinedToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullUndefinedToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarVarToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegVarToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccVarToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackVarToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstVarToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32VarToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32VarToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32VarToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolVarToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullVarToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedVarToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarRegToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegRegToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccRegToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackRegToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstRegToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32RegToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32RegToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32RegToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolRegToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullRegToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedRegToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarAccToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegAccToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccAccToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackAccToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstAccToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32AccToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32AccToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32AccToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolAccToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullAccToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedAccToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarStackToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegStackToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccStackToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackStackToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstStackToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32StackToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32StackToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32StackToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolStackToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullStackToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedStackToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarConstToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegConstToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccConstToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackConstToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstConstToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32ConstToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32ConstToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32ConstToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolConstToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullConstToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedConstToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarF32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegF32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccF32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackF32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstF32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32F32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32F32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32F32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolF32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullF32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarI32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegI32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccI32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackI32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstI32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32I32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32I32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32I32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolI32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullI32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarU32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegU32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccU32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackU32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstU32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32U32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32U32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32U32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolU32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullU32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarBoolToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegBoolToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccBoolToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackBoolToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstBoolToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32BoolToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32BoolToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32BoolToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolBoolToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullBoolToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarNullToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegNullToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccNullToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackNullToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstNullToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32NullToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32NullToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32NullToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolNullToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullNullToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedNullToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarUndefinedToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegUndefinedToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccUndefinedToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackUndefinedToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstUndefinedToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32UndefinedToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32UndefinedToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32UndefinedToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullUndefinedToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarVarToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegVarToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccVarToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackVarToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstVarToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32VarToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32VarToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32VarToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolVarToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullVarToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarRegToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegRegToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccRegToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackRegToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstRegToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32RegToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32RegToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32RegToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolRegToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullRegToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarAccToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegAccToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccAccToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackAccToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstAccToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32AccToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32AccToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32AccToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolAccToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullAccToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarStackToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegStackToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccStackToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackStackToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstStackToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32StackToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32StackToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32StackToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolStackToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullStackToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarConstToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegConstToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccConstToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackConstToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstConstToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32ConstToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32ConstToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32ConstToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolConstToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullConstToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarF32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegF32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccF32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackF32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstF32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32F32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32F32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32F32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolF32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullF32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarI32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegI32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccI32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackI32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstI32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32I32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32I32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32I32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolI32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullI32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarU32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegU32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccU32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackU32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstU32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32U32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32U32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32U32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolU32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullU32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarBoolToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegBoolToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccBoolToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackBoolToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstBoolToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32BoolToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32BoolToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32BoolToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolBoolToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullBoolToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarNullToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegNullToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccNullToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackNullToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstNullToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32NullToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32NullToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32NullToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolNullToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullNullToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarVarToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegVarToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccVarToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackVarToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstVarToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32VarToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32VarToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32VarToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolVarToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullVarToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedVarToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarRegToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegRegToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccRegToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackRegToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstRegToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32RegToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32RegToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32RegToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolRegToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullRegToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedRegToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarAccToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegAccToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccAccToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackAccToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstAccToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32AccToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32AccToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32AccToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolAccToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullAccToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedAccToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarStackToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegStackToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccStackToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackStackToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstStackToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32StackToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32StackToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32StackToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolStackToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullStackToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedStackToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarConstToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegConstToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccConstToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackConstToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstConstToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32ConstToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32ConstToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32ConstToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolConstToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullConstToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedConstToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarF32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegF32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccF32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackF32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstF32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32F32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32F32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32F32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolF32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullF32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarI32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegI32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccI32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackI32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstI32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32I32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32I32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32I32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolI32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullI32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarU32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegU32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccU32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackU32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstU32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32U32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32U32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32U32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolU32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullU32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarBoolToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegBoolToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccBoolToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackBoolToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstBoolToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32BoolToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32BoolToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32BoolToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolBoolToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullBoolToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarNullToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegNullToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccNullToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackNullToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstNullToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32NullToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32NullToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32NullToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolNullToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullNullToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedNullToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftVarUndefinedToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftRegUndefinedToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftAccUndefinedToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftStackUndefinedToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftConstUndefinedToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftF32UndefinedToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftI32UndefinedToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftU32UndefinedToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftNullUndefinedToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::RShiftUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarVarToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegVarToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccVarToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackVarToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstVarToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32VarToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32VarToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32VarToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolVarToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullVarToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedVarToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarRegToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegRegToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccRegToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackRegToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstRegToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32RegToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32RegToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32RegToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolRegToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullRegToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedRegToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarAccToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegAccToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccAccToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackAccToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstAccToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32AccToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32AccToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32AccToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolAccToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullAccToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedAccToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarStackToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegStackToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccStackToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackStackToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstStackToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32StackToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32StackToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32StackToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolStackToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullStackToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedStackToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarConstToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegConstToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccConstToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackConstToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstConstToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32ConstToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32ConstToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32ConstToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolConstToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullConstToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedConstToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarF32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegF32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccF32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackF32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstF32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32F32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32F32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32F32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolF32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullF32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarI32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegI32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccI32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackI32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstI32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32I32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32I32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32I32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolI32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullI32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarU32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegU32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccU32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackU32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstU32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32U32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32U32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32U32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolU32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullU32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarBoolToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegBoolToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccBoolToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackBoolToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstBoolToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32BoolToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32BoolToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32BoolToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolBoolToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullBoolToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarNullToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegNullToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccNullToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackNullToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstNullToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32NullToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32NullToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32NullToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolNullToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullNullToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedNullToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarUndefinedToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegUndefinedToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccUndefinedToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackUndefinedToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstUndefinedToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32UndefinedToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32UndefinedToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32UndefinedToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullUndefinedToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarVarToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegVarToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccVarToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackVarToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstVarToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32VarToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32VarToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32VarToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolVarToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullVarToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedVarToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarRegToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegRegToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccRegToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackRegToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstRegToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32RegToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32RegToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32RegToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolRegToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullRegToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedRegToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarAccToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegAccToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccAccToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackAccToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstAccToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32AccToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32AccToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32AccToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolAccToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullAccToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedAccToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarStackToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegStackToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccStackToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackStackToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstStackToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32StackToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32StackToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32StackToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolStackToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullStackToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedStackToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarConstToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegConstToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccConstToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackConstToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstConstToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32ConstToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32ConstToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32ConstToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolConstToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullConstToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedConstToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarF32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegF32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccF32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackF32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstF32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32F32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32F32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32F32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolF32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullF32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarI32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegI32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccI32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackI32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstI32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32I32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32I32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32I32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolI32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullI32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarU32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegU32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccU32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackU32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstU32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32U32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32U32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32U32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolU32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullU32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarBoolToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegBoolToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccBoolToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackBoolToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstBoolToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32BoolToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32BoolToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32BoolToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolBoolToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullBoolToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarNullToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegNullToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccNullToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackNullToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstNullToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32NullToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32NullToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32NullToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolNullToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullNullToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedNullToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarUndefinedToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegUndefinedToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccUndefinedToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackUndefinedToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstUndefinedToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32UndefinedToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32UndefinedToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32UndefinedToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullUndefinedToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarVarToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegVarToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccVarToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackVarToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstVarToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32VarToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32VarToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32VarToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolVarToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullVarToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarRegToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegRegToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccRegToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackRegToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstRegToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32RegToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32RegToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32RegToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolRegToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullRegToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarAccToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegAccToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccAccToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackAccToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstAccToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32AccToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32AccToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32AccToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolAccToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullAccToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarStackToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegStackToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccStackToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackStackToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstStackToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32StackToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32StackToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32StackToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolStackToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullStackToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarConstToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegConstToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccConstToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackConstToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstConstToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32ConstToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32ConstToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32ConstToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolConstToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullConstToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarF32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegF32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccF32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackF32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstF32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32F32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32F32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32F32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolF32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullF32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarI32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegI32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccI32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackI32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstI32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32I32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32I32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32I32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolI32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullI32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarU32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegU32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccU32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackU32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstU32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32U32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32U32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32U32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolU32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullU32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarBoolToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegBoolToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccBoolToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackBoolToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstBoolToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32BoolToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32BoolToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32BoolToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolBoolToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullBoolToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarNullToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegNullToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccNullToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackNullToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstNullToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32NullToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32NullToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32NullToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolNullToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullNullToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarVarToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegVarToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccVarToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackVarToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstVarToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32VarToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32VarToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32VarToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolVarToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullVarToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedVarToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarRegToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegRegToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccRegToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackRegToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstRegToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32RegToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32RegToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32RegToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolRegToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullRegToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedRegToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarAccToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegAccToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccAccToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackAccToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstAccToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32AccToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32AccToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32AccToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolAccToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullAccToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedAccToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarStackToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegStackToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccStackToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackStackToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstStackToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32StackToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32StackToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32StackToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolStackToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullStackToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedStackToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarConstToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegConstToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccConstToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackConstToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstConstToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32ConstToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32ConstToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32ConstToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolConstToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullConstToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedConstToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarF32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegF32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccF32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackF32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstF32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32F32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32F32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32F32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolF32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullF32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarI32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegI32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccI32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackI32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstI32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32I32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32I32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32I32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolI32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullI32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarU32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegU32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccU32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackU32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstU32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32U32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32U32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32U32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolU32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullU32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarBoolToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegBoolToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccBoolToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackBoolToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstBoolToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32BoolToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32BoolToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32BoolToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolBoolToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullBoolToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarNullToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegNullToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccNullToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackNullToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstNullToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32NullToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32NullToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32NullToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolNullToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullNullToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedNullToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftVarUndefinedToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftRegUndefinedToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftAccUndefinedToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftStackUndefinedToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftConstUndefinedToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftF32UndefinedToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftI32UndefinedToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftU32UndefinedToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftNullUndefinedToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShiftUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::InVarVarToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegVarToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccVarToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackVarToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstVarToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32VarToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32VarToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32VarToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolVarToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullVarToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedVarToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarRegToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegRegToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccRegToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackRegToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstRegToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32RegToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32RegToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32RegToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolRegToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullRegToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedRegToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarAccToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegAccToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccAccToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackAccToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstAccToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32AccToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32AccToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32AccToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolAccToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullAccToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedAccToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarStackToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegStackToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccStackToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackStackToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstStackToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32StackToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32StackToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32StackToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolStackToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullStackToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedStackToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarConstToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegConstToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccConstToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackConstToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstConstToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32ConstToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32ConstToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32ConstToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolConstToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullConstToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedConstToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarF32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegF32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccF32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackF32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstF32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32F32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32F32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32F32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolF32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullF32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarI32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegI32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccI32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackI32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstI32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32I32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32I32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32I32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolI32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullI32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarU32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegU32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccU32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackU32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstU32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32U32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32U32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32U32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolU32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullU32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarBoolToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegBoolToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccBoolToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackBoolToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstBoolToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32BoolToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32BoolToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32BoolToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolBoolToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullBoolToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarNullToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegNullToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccNullToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackNullToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstNullToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32NullToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32NullToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32NullToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolNullToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullNullToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedNullToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarUndefinedToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegUndefinedToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccUndefinedToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackUndefinedToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstUndefinedToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32UndefinedToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32UndefinedToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32UndefinedToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullUndefinedToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarVarToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegVarToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccVarToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackVarToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstVarToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32VarToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32VarToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32VarToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolVarToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullVarToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedVarToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarRegToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegRegToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccRegToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackRegToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstRegToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32RegToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32RegToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32RegToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolRegToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullRegToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedRegToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarAccToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegAccToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccAccToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackAccToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstAccToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32AccToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32AccToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32AccToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolAccToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullAccToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedAccToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarStackToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegStackToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccStackToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackStackToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstStackToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32StackToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32StackToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32StackToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolStackToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullStackToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedStackToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarConstToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegConstToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccConstToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackConstToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstConstToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32ConstToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32ConstToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32ConstToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolConstToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullConstToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedConstToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarF32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegF32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccF32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackF32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstF32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32F32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32F32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32F32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolF32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullF32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarI32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegI32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccI32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackI32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstI32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32I32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32I32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32I32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolI32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullI32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarU32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegU32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccU32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackU32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstU32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32U32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32U32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32U32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolU32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullU32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarBoolToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegBoolToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccBoolToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackBoolToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstBoolToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32BoolToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32BoolToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32BoolToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolBoolToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullBoolToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarNullToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegNullToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccNullToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackNullToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstNullToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32NullToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32NullToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32NullToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolNullToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullNullToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedNullToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarUndefinedToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegUndefinedToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccUndefinedToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackUndefinedToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstUndefinedToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32UndefinedToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32UndefinedToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32UndefinedToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullUndefinedToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarVarToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegVarToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccVarToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackVarToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstVarToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32VarToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32VarToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32VarToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolVarToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullVarToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarRegToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegRegToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccRegToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackRegToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstRegToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32RegToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32RegToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32RegToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolRegToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullRegToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarAccToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegAccToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccAccToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackAccToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstAccToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32AccToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32AccToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32AccToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolAccToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullAccToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarStackToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegStackToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccStackToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackStackToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstStackToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32StackToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32StackToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32StackToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolStackToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullStackToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarConstToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegConstToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccConstToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackConstToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstConstToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32ConstToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32ConstToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32ConstToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolConstToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullConstToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarF32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegF32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccF32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackF32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstF32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32F32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32F32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32F32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolF32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullF32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarI32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegI32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccI32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackI32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstI32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32I32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32I32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32I32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolI32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullI32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarU32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegU32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccU32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackU32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstU32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32U32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32U32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32U32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolU32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullU32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarBoolToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegBoolToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccBoolToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackBoolToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstBoolToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32BoolToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32BoolToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32BoolToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolBoolToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullBoolToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarNullToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegNullToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccNullToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackNullToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstNullToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32NullToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32NullToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32NullToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolNullToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullNullToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarVarToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegVarToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccVarToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackVarToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstVarToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32VarToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32VarToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32VarToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolVarToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullVarToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedVarToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarRegToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegRegToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccRegToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackRegToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstRegToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32RegToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32RegToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32RegToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolRegToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullRegToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedRegToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarAccToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegAccToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccAccToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackAccToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstAccToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32AccToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32AccToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32AccToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolAccToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullAccToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedAccToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarStackToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegStackToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccStackToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackStackToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstStackToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32StackToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32StackToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32StackToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolStackToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullStackToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedStackToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarConstToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegConstToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccConstToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackConstToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstConstToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32ConstToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32ConstToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32ConstToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolConstToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullConstToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedConstToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarF32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegF32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccF32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackF32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstF32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32F32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32F32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32F32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolF32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullF32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarI32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegI32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccI32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackI32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstI32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32I32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32I32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32I32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolI32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullI32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarU32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegU32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccU32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackU32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstU32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32U32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32U32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32U32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolU32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullU32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarBoolToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegBoolToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccBoolToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackBoolToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstBoolToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32BoolToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32BoolToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32BoolToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolBoolToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullBoolToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarNullToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegNullToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccNullToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackNullToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstNullToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32NullToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32NullToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32NullToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolNullToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullNullToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedNullToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InVarUndefinedToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InRegUndefinedToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InAccUndefinedToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InStackUndefinedToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InConstUndefinedToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InF32UndefinedToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InI32UndefinedToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InU32UndefinedToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InNullUndefinedToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::in_(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarVarToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegVarToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccVarToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackVarToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstVarToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32VarToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32VarToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32VarToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolVarToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullVarToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedVarToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarRegToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegRegToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccRegToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackRegToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstRegToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32RegToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32RegToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32RegToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolRegToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullRegToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedRegToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarAccToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegAccToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccAccToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackAccToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstAccToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32AccToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32AccToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32AccToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolAccToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullAccToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedAccToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarStackToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegStackToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccStackToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackStackToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstStackToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32StackToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32StackToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32StackToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolStackToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullStackToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedStackToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarConstToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegConstToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccConstToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackConstToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstConstToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32ConstToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32ConstToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32ConstToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolConstToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullConstToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedConstToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarF32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegF32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccF32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackF32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstF32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32F32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32F32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32F32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolF32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullF32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarI32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegI32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccI32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackI32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstI32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32I32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32I32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32I32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolI32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullI32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarU32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegU32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccU32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackU32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstU32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32U32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32U32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32U32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolU32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullU32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarBoolToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegBoolToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccBoolToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackBoolToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstBoolToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32BoolToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32BoolToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32BoolToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolBoolToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullBoolToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarNullToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegNullToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccNullToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackNullToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstNullToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32NullToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32NullToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32NullToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolNullToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullNullToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedNullToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarUndefinedToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegUndefinedToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccUndefinedToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackUndefinedToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstUndefinedToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32UndefinedToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32UndefinedToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32UndefinedToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullUndefinedToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarVarToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegVarToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccVarToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackVarToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstVarToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32VarToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32VarToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32VarToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolVarToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullVarToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedVarToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarRegToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegRegToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccRegToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackRegToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstRegToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32RegToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32RegToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32RegToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolRegToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullRegToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedRegToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarAccToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegAccToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccAccToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackAccToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstAccToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32AccToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32AccToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32AccToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolAccToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullAccToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedAccToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarStackToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegStackToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccStackToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackStackToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstStackToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32StackToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32StackToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32StackToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolStackToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullStackToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedStackToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarConstToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegConstToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccConstToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackConstToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstConstToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32ConstToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32ConstToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32ConstToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolConstToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullConstToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedConstToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarF32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegF32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccF32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackF32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstF32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32F32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32F32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32F32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolF32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullF32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarI32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegI32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccI32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackI32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstI32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32I32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32I32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32I32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolI32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullI32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarU32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegU32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccU32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackU32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstU32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32U32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32U32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32U32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolU32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullU32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarBoolToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegBoolToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccBoolToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackBoolToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstBoolToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32BoolToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32BoolToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32BoolToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolBoolToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullBoolToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarNullToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegNullToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccNullToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackNullToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstNullToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32NullToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32NullToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32NullToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolNullToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullNullToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedNullToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarUndefinedToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegUndefinedToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccUndefinedToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackUndefinedToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstUndefinedToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32UndefinedToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32UndefinedToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32UndefinedToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullUndefinedToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarVarToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegVarToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccVarToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackVarToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstVarToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32VarToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32VarToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32VarToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolVarToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullVarToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarRegToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegRegToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccRegToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackRegToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstRegToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32RegToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32RegToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32RegToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolRegToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullRegToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarAccToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegAccToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccAccToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackAccToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstAccToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32AccToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32AccToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32AccToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolAccToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullAccToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarStackToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegStackToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccStackToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackStackToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstStackToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32StackToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32StackToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32StackToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolStackToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullStackToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarConstToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegConstToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccConstToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackConstToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstConstToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32ConstToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32ConstToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32ConstToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolConstToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullConstToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarF32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegF32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccF32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackF32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstF32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32F32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32F32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32F32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolF32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullF32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarI32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegI32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccI32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackI32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstI32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32I32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32I32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32I32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolI32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullI32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarU32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegU32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccU32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackU32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstU32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32U32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32U32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32U32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolU32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullU32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarBoolToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegBoolToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccBoolToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackBoolToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstBoolToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32BoolToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32BoolToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32BoolToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolBoolToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullBoolToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarNullToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegNullToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccNullToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackNullToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstNullToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32NullToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32NullToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32NullToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolNullToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullNullToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarVarToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegVarToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccVarToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackVarToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstVarToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32VarToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32VarToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32VarToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolVarToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullVarToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedVarToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarRegToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegRegToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccRegToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackRegToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstRegToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32RegToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32RegToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32RegToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolRegToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullRegToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedRegToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarAccToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegAccToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccAccToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackAccToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstAccToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32AccToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32AccToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32AccToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolAccToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullAccToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedAccToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarStackToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegStackToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccStackToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackStackToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstStackToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32StackToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32StackToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32StackToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolStackToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullStackToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedStackToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarConstToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegConstToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccConstToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackConstToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstConstToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32ConstToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32ConstToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32ConstToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolConstToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullConstToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedConstToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarF32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegF32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccF32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackF32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstF32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32F32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32F32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32F32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolF32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullF32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarI32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegI32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccI32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackI32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstI32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32I32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32I32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32I32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolI32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullI32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarU32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegU32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccU32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackU32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstU32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32U32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32U32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32U32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolU32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullU32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarBoolToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegBoolToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccBoolToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackBoolToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstBoolToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32BoolToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32BoolToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32BoolToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolBoolToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullBoolToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarNullToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegNullToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccNullToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackNullToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstNullToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32NullToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32NullToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32NullToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolNullToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullNullToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedNullToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfVarUndefinedToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfRegUndefinedToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfAccUndefinedToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfStackUndefinedToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfConstUndefinedToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfF32UndefinedToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfI32UndefinedToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfU32UndefinedToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfNullUndefinedToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::InstanceOfUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::ExpVarVarToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegVarToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccVarToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackVarToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstVarToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32VarToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32VarToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32VarToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolVarToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullVarToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedVarToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarRegToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegRegToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccRegToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackRegToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstRegToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32RegToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32RegToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32RegToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolRegToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullRegToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedRegToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarAccToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegAccToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccAccToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackAccToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstAccToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32AccToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32AccToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32AccToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolAccToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullAccToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedAccToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarStackToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegStackToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccStackToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackStackToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstStackToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32StackToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32StackToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32StackToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolStackToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullStackToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedStackToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarConstToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegConstToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccConstToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackConstToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstConstToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32ConstToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32ConstToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32ConstToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolConstToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullConstToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedConstToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarF32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegF32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccF32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackF32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstF32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32F32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32F32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32F32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolF32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullF32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarI32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegI32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccI32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackI32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstI32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32I32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32I32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32I32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolI32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullI32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarU32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegU32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccU32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackU32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstU32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32U32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32U32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32U32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolU32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullU32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarBoolToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegBoolToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccBoolToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackBoolToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstBoolToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32BoolToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32BoolToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32BoolToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolBoolToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullBoolToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarNullToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegNullToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccNullToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackNullToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstNullToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32NullToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32NullToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32NullToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolNullToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullNullToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedNullToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarUndefinedToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegUndefinedToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccUndefinedToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackUndefinedToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstUndefinedToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32UndefinedToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32UndefinedToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32UndefinedToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullUndefinedToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarVarToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegVarToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccVarToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackVarToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstVarToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32VarToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32VarToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32VarToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolVarToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullVarToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedVarToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarRegToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegRegToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccRegToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackRegToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstRegToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32RegToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32RegToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32RegToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolRegToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullRegToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedRegToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarAccToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegAccToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccAccToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackAccToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstAccToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32AccToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32AccToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32AccToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolAccToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullAccToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedAccToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarStackToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegStackToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccStackToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackStackToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstStackToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32StackToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32StackToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32StackToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolStackToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullStackToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedStackToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarConstToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegConstToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccConstToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackConstToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstConstToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32ConstToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32ConstToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32ConstToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolConstToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullConstToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedConstToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarF32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegF32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccF32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackF32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstF32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32F32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32F32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32F32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolF32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullF32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarI32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegI32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccI32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackI32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstI32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32I32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32I32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32I32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolI32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullI32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarU32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegU32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccU32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackU32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstU32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32U32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32U32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32U32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolU32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullU32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarBoolToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegBoolToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccBoolToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackBoolToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstBoolToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32BoolToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32BoolToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32BoolToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolBoolToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullBoolToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarNullToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegNullToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccNullToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackNullToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstNullToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32NullToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32NullToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32NullToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolNullToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullNullToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedNullToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarUndefinedToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegUndefinedToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccUndefinedToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackUndefinedToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstUndefinedToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32UndefinedToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32UndefinedToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32UndefinedToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullUndefinedToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarVarToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegVarToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccVarToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackVarToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstVarToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32VarToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32VarToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32VarToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolVarToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullVarToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarRegToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegRegToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccRegToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackRegToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstRegToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32RegToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32RegToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32RegToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolRegToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullRegToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarAccToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegAccToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccAccToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackAccToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstAccToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32AccToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32AccToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32AccToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolAccToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullAccToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarStackToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegStackToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccStackToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackStackToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstStackToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32StackToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32StackToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32StackToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolStackToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullStackToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarConstToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegConstToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccConstToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackConstToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstConstToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32ConstToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32ConstToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32ConstToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolConstToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullConstToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarF32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegF32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccF32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackF32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstF32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32F32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32F32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32F32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolF32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullF32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarI32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegI32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccI32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackI32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstI32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32I32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32I32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32I32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolI32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullI32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarU32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegU32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccU32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackU32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstU32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32U32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32U32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32U32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolU32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullU32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarBoolToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegBoolToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccBoolToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackBoolToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstBoolToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32BoolToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32BoolToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32BoolToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolBoolToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullBoolToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarNullToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegNullToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccNullToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackNullToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstNullToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32NullToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32NullToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32NullToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolNullToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullNullToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarVarToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegVarToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccVarToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackVarToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstVarToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32VarToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32VarToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32VarToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolVarToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullVarToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedVarToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarRegToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegRegToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccRegToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackRegToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstRegToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32RegToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32RegToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32RegToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolRegToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullRegToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedRegToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarAccToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegAccToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccAccToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackAccToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstAccToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32AccToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32AccToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32AccToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolAccToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullAccToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedAccToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarStackToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegStackToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccStackToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackStackToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstStackToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32StackToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32StackToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32StackToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolStackToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullStackToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedStackToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarConstToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegConstToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccConstToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackConstToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstConstToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32ConstToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32ConstToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32ConstToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolConstToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullConstToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedConstToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarF32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegF32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccF32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackF32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstF32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32F32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32F32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32F32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolF32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullF32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarI32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegI32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccI32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackI32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstI32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32I32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32I32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32I32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolI32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullI32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarU32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegU32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccU32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackU32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstU32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32U32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32U32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32U32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolU32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullU32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarBoolToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegBoolToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccBoolToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackBoolToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstBoolToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32BoolToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32BoolToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32BoolToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolBoolToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullBoolToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarNullToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegNullToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccNullToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackNullToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstNullToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32NullToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32NullToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32NullToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolNullToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullNullToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedNullToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpVarUndefinedToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpRegUndefinedToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpAccUndefinedToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpStackUndefinedToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpConstUndefinedToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpF32UndefinedToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpI32UndefinedToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpU32UndefinedToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpNullUndefinedToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::ExpUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::exp(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarVarToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegVarToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccVarToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackVarToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstVarToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32VarToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32VarToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32VarToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolVarToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullVarToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedVarToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarRegToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegRegToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccRegToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackRegToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstRegToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32RegToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32RegToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32RegToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolRegToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullRegToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedRegToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarAccToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegAccToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccAccToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackAccToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstAccToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32AccToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32AccToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32AccToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolAccToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullAccToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedAccToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarStackToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegStackToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccStackToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackStackToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstStackToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32StackToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32StackToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32StackToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolStackToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullStackToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedStackToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarConstToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegConstToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccConstToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackConstToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstConstToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32ConstToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32ConstToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32ConstToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolConstToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullConstToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedConstToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarF32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegF32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccF32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackF32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstF32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32F32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32F32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32F32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolF32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullF32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarI32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegI32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccI32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackI32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstI32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32I32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32I32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32I32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolI32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullI32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarU32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegU32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccU32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackU32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstU32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32U32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32U32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32U32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolU32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullU32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarBoolToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegBoolToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccBoolToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackBoolToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstBoolToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32BoolToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32BoolToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32BoolToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolBoolToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullBoolToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarNullToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegNullToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccNullToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackNullToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstNullToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32NullToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32NullToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32NullToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolNullToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullNullToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedNullToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarUndefinedToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegUndefinedToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccUndefinedToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackUndefinedToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstUndefinedToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32UndefinedToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32UndefinedToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32UndefinedToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullUndefinedToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarVarToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegVarToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccVarToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackVarToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstVarToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32VarToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32VarToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32VarToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolVarToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullVarToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedVarToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarRegToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegRegToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccRegToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackRegToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstRegToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32RegToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32RegToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32RegToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolRegToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullRegToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedRegToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarAccToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegAccToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccAccToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackAccToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstAccToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32AccToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32AccToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32AccToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolAccToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullAccToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedAccToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarStackToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegStackToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccStackToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackStackToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstStackToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32StackToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32StackToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32StackToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolStackToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullStackToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedStackToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarConstToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegConstToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccConstToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackConstToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstConstToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32ConstToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32ConstToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32ConstToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolConstToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullConstToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedConstToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarF32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegF32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccF32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackF32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstF32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32F32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32F32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32F32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolF32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullF32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarI32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegI32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccI32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackI32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstI32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32I32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32I32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32I32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolI32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullI32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarU32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegU32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccU32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackU32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstU32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32U32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32U32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32U32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolU32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullU32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarBoolToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegBoolToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccBoolToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackBoolToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstBoolToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32BoolToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32BoolToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32BoolToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolBoolToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullBoolToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarNullToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegNullToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccNullToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackNullToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstNullToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32NullToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32NullToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32NullToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolNullToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullNullToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedNullToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarUndefinedToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegUndefinedToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccUndefinedToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackUndefinedToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstUndefinedToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32UndefinedToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32UndefinedToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32UndefinedToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullUndefinedToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarVarToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegVarToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccVarToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackVarToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstVarToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32VarToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32VarToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32VarToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolVarToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullVarToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarRegToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegRegToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccRegToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackRegToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstRegToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32RegToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32RegToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32RegToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolRegToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullRegToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarAccToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegAccToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccAccToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackAccToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstAccToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32AccToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32AccToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32AccToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolAccToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullAccToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarStackToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegStackToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccStackToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackStackToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstStackToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32StackToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32StackToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32StackToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolStackToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullStackToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarConstToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegConstToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccConstToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackConstToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstConstToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32ConstToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32ConstToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32ConstToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolConstToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullConstToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarF32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegF32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccF32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackF32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstF32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32F32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32F32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32F32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolF32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullF32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarI32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegI32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccI32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackI32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstI32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32I32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32I32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32I32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolI32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullI32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarU32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegU32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccU32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackU32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstU32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32U32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32U32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32U32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolU32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullU32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarBoolToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegBoolToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccBoolToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackBoolToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstBoolToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32BoolToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32BoolToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32BoolToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolBoolToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullBoolToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarNullToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegNullToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccNullToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackNullToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstNullToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32NullToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32NullToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32NullToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolNullToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullNullToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarVarToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegVarToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccVarToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackVarToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstVarToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32VarToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32VarToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32VarToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolVarToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullVarToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedVarToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarRegToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegRegToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccRegToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackRegToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstRegToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32RegToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32RegToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32RegToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolRegToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullRegToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedRegToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarAccToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegAccToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccAccToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackAccToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstAccToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32AccToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32AccToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32AccToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolAccToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullAccToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedAccToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarStackToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegStackToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccStackToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackStackToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstStackToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32StackToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32StackToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32StackToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolStackToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullStackToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedStackToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarConstToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegConstToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccConstToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackConstToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstConstToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32ConstToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32ConstToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32ConstToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolConstToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullConstToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedConstToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarF32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegF32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccF32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackF32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstF32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32F32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32F32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32F32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolF32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullF32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarI32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegI32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccI32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackI32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstI32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32I32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32I32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32I32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolI32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullI32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarU32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegU32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccU32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackU32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstU32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32U32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32U32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32U32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolU32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullU32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarBoolToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegBoolToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccBoolToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackBoolToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstBoolToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32BoolToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32BoolToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32BoolToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolBoolToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullBoolToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarNullToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegNullToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccNullToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackNullToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstNullToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32NullToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32NullToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32NullToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolNullToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullNullToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedNullToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingVarUndefinedToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingRegUndefinedToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingAccUndefinedToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingStackUndefinedToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingConstUndefinedToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingF32UndefinedToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingI32UndefinedToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingU32UndefinedToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingNullUndefinedToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::NullishCoalescingUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::DecVarToVar(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecRegToVar(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecAccToVar(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecStackToVar(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecConstToVar(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecF32ToVar(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecI32ToVar(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecU32ToVar(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecBoolToVar(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecNullToVar(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecUndefinedToVar(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecVarToReg(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecRegToReg(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecAccToReg(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecStackToReg(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecConstToReg(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecF32ToReg(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecI32ToReg(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecU32ToReg(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecBoolToReg(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecNullToReg(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecUndefinedToReg(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecVarToAcc(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecRegToAcc(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecAccToAcc(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecStackToAcc(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecConstToAcc(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecF32ToAcc(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecI32ToAcc(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecU32ToAcc(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecBoolToAcc(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecNullToAcc(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecUndefinedToAcc(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecVarToStack(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecRegToStack(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecAccToStack(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecStackToStack(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecConstToStack(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecF32ToStack(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecI32ToStack(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecU32ToStack(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecBoolToStack(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecNullToStack(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::DecUndefinedToStack(arg0, output) => {
                instruction::dec(arg0, output, vm)?
            }
            Self::IncVarToVar(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncRegToVar(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncAccToVar(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncStackToVar(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncConstToVar(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncF32ToVar(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncI32ToVar(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncU32ToVar(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncBoolToVar(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncNullToVar(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncUndefinedToVar(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncVarToReg(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncRegToReg(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncAccToReg(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncStackToReg(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncConstToReg(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncF32ToReg(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncI32ToReg(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncU32ToReg(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncBoolToReg(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncNullToReg(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncUndefinedToReg(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncVarToAcc(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncRegToAcc(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncAccToAcc(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncStackToAcc(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncConstToAcc(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncF32ToAcc(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncI32ToAcc(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncU32ToAcc(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncBoolToAcc(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncNullToAcc(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncUndefinedToAcc(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncVarToStack(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncRegToStack(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncAccToStack(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncStackToStack(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncConstToStack(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncF32ToStack(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncI32ToStack(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncU32ToStack(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncBoolToStack(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncNullToStack(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::IncUndefinedToStack(arg0, output) => {
                instruction::inc(arg0, output, vm)?
            }
            Self::PushScope => instruction::push_scope(vm)?,
            Self::PushLoopScope => instruction::push_loop_scope(vm)?,
            Self::PopScope => instruction::pop_scope(vm)?,
            Self::CallVarToVar(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallRegToVar(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallAccToVar(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallStackToVar(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallConstToVar(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallF32ToVar(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallI32ToVar(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallU32ToVar(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallBoolToVar(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallNullToVar(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallUndefinedToVar(arg0, output) => {
                instruction::call(arg0, output, vm)?
            }
            Self::CallVarToReg(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallRegToReg(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallAccToReg(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallStackToReg(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallConstToReg(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallF32ToReg(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallI32ToReg(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallU32ToReg(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallBoolToReg(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallNullToReg(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallUndefinedToReg(arg0, output) => {
                instruction::call(arg0, output, vm)?
            }
            Self::CallVarToAcc(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallRegToAcc(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallAccToAcc(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallStackToAcc(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallConstToAcc(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallF32ToAcc(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallI32ToAcc(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallU32ToAcc(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallBoolToAcc(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallNullToAcc(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallUndefinedToAcc(arg0, output) => {
                instruction::call(arg0, output, vm)?
            }
            Self::CallVarToStack(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallRegToStack(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallAccToStack(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallStackToStack(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallConstToStack(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallF32ToStack(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallI32ToStack(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallU32ToStack(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallBoolToStack(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallNullToStack(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallUndefinedToStack(arg0, output) => {
                instruction::call(arg0, output, vm)?
            }
            Self::CallNoOutputVar(arg0) => instruction::call_no_output(arg0, vm)?,
            Self::CallNoOutputReg(arg0) => instruction::call_no_output(arg0, vm)?,
            Self::CallNoOutputAcc(arg0) => instruction::call_no_output(arg0, vm)?,
            Self::CallNoOutputStack(arg0) => instruction::call_no_output(arg0, vm)?,
            Self::CallNoOutputConst(arg0) => instruction::call_no_output(arg0, vm)?,
            Self::CallNoOutputF32(arg0) => instruction::call_no_output(arg0, vm)?,
            Self::CallNoOutputI32(arg0) => instruction::call_no_output(arg0, vm)?,
            Self::CallNoOutputU32(arg0) => instruction::call_no_output(arg0, vm)?,
            Self::CallNoOutputBool(arg0) => instruction::call_no_output(arg0, vm)?,
            Self::CallNoOutputNull(arg0) => instruction::call_no_output(arg0, vm)?,
            Self::CallNoOutputUndefined(arg0) => instruction::call_no_output(arg0, vm)?,
            Self::CallMemberVarVarToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegVarToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccVarToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackVarToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstVarToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32VarToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32VarToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32VarToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolVarToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullVarToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedVarToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarRegToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegRegToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccRegToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackRegToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstRegToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32RegToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32RegToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32RegToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolRegToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullRegToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedRegToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarAccToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegAccToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccAccToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackAccToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstAccToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32AccToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32AccToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32AccToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolAccToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullAccToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedAccToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarStackToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegStackToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccStackToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackStackToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstStackToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32StackToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32StackToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32StackToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolStackToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullStackToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedStackToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarConstToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegConstToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccConstToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackConstToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstConstToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32ConstToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32ConstToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32ConstToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolConstToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullConstToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedConstToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarF32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegF32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccF32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackF32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstF32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32F32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32F32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32F32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolF32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullF32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarI32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegI32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccI32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackI32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstI32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32I32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32I32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32I32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolI32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullI32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarU32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegU32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccU32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackU32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstU32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32U32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32U32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32U32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolU32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullU32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarBoolToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegBoolToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccBoolToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackBoolToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstBoolToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32BoolToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32BoolToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32BoolToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolBoolToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullBoolToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarNullToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegNullToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccNullToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackNullToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstNullToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32NullToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32NullToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32NullToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolNullToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullNullToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedNullToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarUndefinedToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegUndefinedToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccUndefinedToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackUndefinedToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstUndefinedToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32UndefinedToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32UndefinedToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32UndefinedToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullUndefinedToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarVarToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegVarToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccVarToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackVarToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstVarToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32VarToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32VarToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32VarToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolVarToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullVarToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedVarToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarRegToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegRegToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccRegToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackRegToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstRegToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32RegToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32RegToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32RegToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolRegToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullRegToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedRegToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarAccToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegAccToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccAccToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackAccToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstAccToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32AccToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32AccToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32AccToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolAccToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullAccToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedAccToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarStackToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegStackToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccStackToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackStackToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstStackToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32StackToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32StackToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32StackToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolStackToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullStackToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedStackToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarConstToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegConstToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccConstToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackConstToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstConstToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32ConstToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32ConstToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32ConstToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolConstToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullConstToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedConstToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarF32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegF32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccF32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackF32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstF32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32F32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32F32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32F32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolF32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullF32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarI32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegI32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccI32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackI32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstI32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32I32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32I32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32I32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolI32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullI32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarU32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegU32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccU32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackU32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstU32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32U32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32U32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32U32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolU32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullU32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarBoolToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegBoolToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccBoolToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackBoolToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstBoolToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32BoolToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32BoolToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32BoolToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolBoolToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullBoolToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarNullToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegNullToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccNullToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackNullToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstNullToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32NullToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32NullToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32NullToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolNullToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullNullToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedNullToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarUndefinedToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegUndefinedToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccUndefinedToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackUndefinedToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstUndefinedToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32UndefinedToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32UndefinedToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32UndefinedToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullUndefinedToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarVarToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegVarToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccVarToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackVarToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstVarToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32VarToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32VarToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32VarToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolVarToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullVarToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarRegToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegRegToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccRegToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackRegToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstRegToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32RegToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32RegToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32RegToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolRegToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullRegToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarAccToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegAccToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccAccToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackAccToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstAccToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32AccToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32AccToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32AccToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolAccToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullAccToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarStackToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegStackToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccStackToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackStackToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstStackToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32StackToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32StackToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32StackToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolStackToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullStackToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarConstToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegConstToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccConstToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackConstToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstConstToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32ConstToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32ConstToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32ConstToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolConstToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullConstToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarF32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegF32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccF32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackF32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstF32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32F32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32F32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32F32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolF32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullF32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarI32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegI32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccI32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackI32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstI32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32I32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32I32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32I32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolI32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullI32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarU32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegU32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccU32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackU32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstU32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32U32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32U32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32U32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolU32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullU32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarBoolToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegBoolToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccBoolToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackBoolToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstBoolToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32BoolToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32BoolToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32BoolToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolBoolToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullBoolToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarNullToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegNullToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccNullToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackNullToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstNullToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32NullToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32NullToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32NullToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolNullToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullNullToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarVarToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegVarToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccVarToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackVarToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstVarToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32VarToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32VarToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32VarToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolVarToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullVarToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedVarToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarRegToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegRegToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccRegToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackRegToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstRegToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32RegToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32RegToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32RegToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolRegToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullRegToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedRegToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarAccToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegAccToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccAccToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackAccToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstAccToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32AccToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32AccToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32AccToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolAccToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullAccToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedAccToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarStackToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegStackToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccStackToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackStackToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstStackToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32StackToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32StackToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32StackToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolStackToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullStackToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedStackToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarConstToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegConstToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccConstToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackConstToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstConstToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32ConstToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32ConstToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32ConstToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolConstToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullConstToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedConstToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarF32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegF32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccF32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackF32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstF32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32F32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32F32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32F32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolF32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullF32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarI32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegI32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccI32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackI32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstI32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32I32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32I32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32I32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolI32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullI32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarU32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegU32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccU32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackU32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstU32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32U32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32U32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32U32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolU32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullU32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarBoolToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegBoolToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccBoolToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackBoolToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstBoolToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32BoolToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32BoolToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32BoolToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolBoolToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullBoolToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarNullToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegNullToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccNullToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackNullToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstNullToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32NullToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32NullToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32NullToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolNullToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullNullToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedNullToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberVarUndefinedToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberRegUndefinedToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberAccUndefinedToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberStackUndefinedToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberConstUndefinedToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberF32UndefinedToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberI32UndefinedToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberU32UndefinedToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNullUndefinedToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNoOutputVarVar(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputRegVar(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputAccVar(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputStackVar(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputConstVar(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputF32Var(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputI32Var(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputU32Var(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputBoolVar(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputNullVar(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputUndefinedVar(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputVarReg(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputRegReg(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputAccReg(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputStackReg(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputConstReg(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputF32Reg(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputI32Reg(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputU32Reg(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputBoolReg(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputNullReg(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputUndefinedReg(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputVarAcc(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputRegAcc(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputAccAcc(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputStackAcc(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputConstAcc(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputF32Acc(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputI32Acc(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputU32Acc(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputBoolAcc(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputNullAcc(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputUndefinedAcc(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputVarStack(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputRegStack(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputAccStack(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputStackStack(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputConstStack(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputF32Stack(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputI32Stack(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputU32Stack(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputBoolStack(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputNullStack(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputUndefinedStack(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputVarConst(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputRegConst(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputAccConst(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputStackConst(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputConstConst(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputF32Const(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputI32Const(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputU32Const(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputBoolConst(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputNullConst(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputUndefinedConst(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputVarF32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputRegF32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputAccF32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputStackF32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputConstF32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputF32F32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputI32F32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputU32F32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputBoolF32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputNullF32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputUndefinedF32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputVarI32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputRegI32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputAccI32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputStackI32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputConstI32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputF32I32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputI32I32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputU32I32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputBoolI32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputNullI32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputUndefinedI32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputVarU32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputRegU32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputAccU32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputStackU32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputConstU32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputF32U32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputI32U32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputU32U32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputBoolU32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputNullU32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputUndefinedU32(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputVarBool(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputRegBool(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputAccBool(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputStackBool(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputConstBool(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputF32Bool(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputI32Bool(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputU32Bool(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputBoolBool(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputNullBool(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputUndefinedBool(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputVarNull(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputRegNull(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputAccNull(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputStackNull(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputConstNull(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputF32Null(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputI32Null(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputU32Null(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputBoolNull(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputNullNull(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputUndefinedNull(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputVarUndefined(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputRegUndefined(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputAccUndefined(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputStackUndefined(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputConstUndefined(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputF32Undefined(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputI32Undefined(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputU32Undefined(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputBoolUndefined(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputNullUndefined(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallMemberNoOutputUndefinedUndefined(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallSuperToVar(output) => instruction::call_super(output, vm)?,
            Self::CallSuperToReg(output) => instruction::call_super(output, vm)?,
            Self::CallSuperToAcc(output) => instruction::call_super(output, vm)?,
            Self::CallSuperToStack(output) => instruction::call_super(output, vm)?,
            Self::CallSuperNoOutput => instruction::call_super_no_output(vm)?,
            Self::ConstructVarToVar(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructRegToVar(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructAccToVar(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructStackToVar(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructConstToVar(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructF32ToVar(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructI32ToVar(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructU32ToVar(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructBoolToVar(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructNullToVar(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructUndefinedToVar(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructVarToReg(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructRegToReg(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructAccToReg(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructStackToReg(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructConstToReg(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructF32ToReg(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructI32ToReg(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructU32ToReg(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructBoolToReg(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructNullToReg(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructUndefinedToReg(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructVarToAcc(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructRegToAcc(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructAccToAcc(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructStackToAcc(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructConstToAcc(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructF32ToAcc(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructI32ToAcc(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructU32ToAcc(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructBoolToAcc(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructNullToAcc(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructUndefinedToAcc(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructVarToStack(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructRegToStack(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructAccToStack(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructStackToStack(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructConstToStack(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructF32ToStack(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructI32ToStack(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructU32ToStack(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructBoolToStack(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructNullToStack(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructUndefinedToStack(arg0, output) => {
                instruction::construct(arg0, output, vm)?
            }
            Self::ConstructNoOutputVar(arg0) => {
                instruction::construct_no_output(arg0, vm)?
            }
            Self::ConstructNoOutputReg(arg0) => {
                instruction::construct_no_output(arg0, vm)?
            }
            Self::ConstructNoOutputAcc(arg0) => {
                instruction::construct_no_output(arg0, vm)?
            }
            Self::ConstructNoOutputStack(arg0) => {
                instruction::construct_no_output(arg0, vm)?
            }
            Self::ConstructNoOutputConst(arg0) => {
                instruction::construct_no_output(arg0, vm)?
            }
            Self::ConstructNoOutputF32(arg0) => {
                instruction::construct_no_output(arg0, vm)?
            }
            Self::ConstructNoOutputI32(arg0) => {
                instruction::construct_no_output(arg0, vm)?
            }
            Self::ConstructNoOutputU32(arg0) => {
                instruction::construct_no_output(arg0, vm)?
            }
            Self::ConstructNoOutputBool(arg0) => {
                instruction::construct_no_output(arg0, vm)?
            }
            Self::ConstructNoOutputNull(arg0) => {
                instruction::construct_no_output(arg0, vm)?
            }
            Self::ConstructNoOutputUndefined(arg0) => {
                instruction::construct_no_output(arg0, vm)?
            }
            Self::PushCallVar(arg0) => instruction::push_call(arg0, vm)?,
            Self::PushCallReg(arg0) => instruction::push_call(arg0, vm)?,
            Self::PushCallAcc(arg0) => instruction::push_call(arg0, vm)?,
            Self::PushCallStack(arg0) => instruction::push_call(arg0, vm)?,
            Self::PushCallConst(arg0) => instruction::push_call(arg0, vm)?,
            Self::PushCallF32(arg0) => instruction::push_call(arg0, vm)?,
            Self::PushCallI32(arg0) => instruction::push_call(arg0, vm)?,
            Self::PushCallU32(arg0) => instruction::push_call(arg0, vm)?,
            Self::PushCallBool(arg0) => instruction::push_call(arg0, vm)?,
            Self::PushCallNull(arg0) => instruction::push_call(arg0, vm)?,
            Self::PushCallUndefined(arg0) => instruction::push_call(arg0, vm)?,
            Self::SpreadCallVar(arg0) => instruction::spread_call(arg0, vm)?,
            Self::SpreadCallReg(arg0) => instruction::spread_call(arg0, vm)?,
            Self::SpreadCallAcc(arg0) => instruction::spread_call(arg0, vm)?,
            Self::SpreadCallStack(arg0) => instruction::spread_call(arg0, vm)?,
            Self::SpreadCallConst(arg0) => instruction::spread_call(arg0, vm)?,
            Self::SpreadCallF32(arg0) => instruction::spread_call(arg0, vm)?,
            Self::SpreadCallI32(arg0) => instruction::spread_call(arg0, vm)?,
            Self::SpreadCallU32(arg0) => instruction::spread_call(arg0, vm)?,
            Self::SpreadCallBool(arg0) => instruction::spread_call(arg0, vm)?,
            Self::SpreadCallNull(arg0) => instruction::spread_call(arg0, vm)?,
            Self::SpreadCallUndefined(arg0) => instruction::spread_call(arg0, vm)?,
            Self::Jmp(arg0) => instruction::jmp(arg0, vm)?,
            Self::JmpIfVar(arg0, arg1) => instruction::jmp_if(arg0, arg1, vm)?,
            Self::JmpIfReg(arg0, arg1) => instruction::jmp_if(arg0, arg1, vm)?,
            Self::JmpIfAcc(arg0, arg1) => instruction::jmp_if(arg0, arg1, vm)?,
            Self::JmpIfStack(arg0, arg1) => instruction::jmp_if(arg0, arg1, vm)?,
            Self::JmpIfConst(arg0, arg1) => instruction::jmp_if(arg0, arg1, vm)?,
            Self::JmpIfF32(arg0, arg1) => instruction::jmp_if(arg0, arg1, vm)?,
            Self::JmpIfI32(arg0, arg1) => instruction::jmp_if(arg0, arg1, vm)?,
            Self::JmpIfU32(arg0, arg1) => instruction::jmp_if(arg0, arg1, vm)?,
            Self::JmpIfBool(arg0, arg1) => instruction::jmp_if(arg0, arg1, vm)?,
            Self::JmpIfNull(arg0, arg1) => instruction::jmp_if(arg0, arg1, vm)?,
            Self::JmpIfUndefined(arg0, arg1) => instruction::jmp_if(arg0, arg1, vm)?,
            Self::JmpIfNotVar(arg0, arg1) => instruction::jmp_if_not(arg0, arg1, vm)?,
            Self::JmpIfNotReg(arg0, arg1) => instruction::jmp_if_not(arg0, arg1, vm)?,
            Self::JmpIfNotAcc(arg0, arg1) => instruction::jmp_if_not(arg0, arg1, vm)?,
            Self::JmpIfNotStack(arg0, arg1) => instruction::jmp_if_not(arg0, arg1, vm)?,
            Self::JmpIfNotConst(arg0, arg1) => instruction::jmp_if_not(arg0, arg1, vm)?,
            Self::JmpIfNotF32(arg0, arg1) => instruction::jmp_if_not(arg0, arg1, vm)?,
            Self::JmpIfNotI32(arg0, arg1) => instruction::jmp_if_not(arg0, arg1, vm)?,
            Self::JmpIfNotU32(arg0, arg1) => instruction::jmp_if_not(arg0, arg1, vm)?,
            Self::JmpIfNotBool(arg0, arg1) => instruction::jmp_if_not(arg0, arg1, vm)?,
            Self::JmpIfNotNull(arg0, arg1) => instruction::jmp_if_not(arg0, arg1, vm)?,
            Self::JmpIfNotUndefined(arg0, arg1) => {
                instruction::jmp_if_not(arg0, arg1, vm)?
            }
            Self::JmpIfNullVar(arg0, arg1) => instruction::jmp_if_null(arg0, arg1, vm)?,
            Self::JmpIfNullReg(arg0, arg1) => instruction::jmp_if_null(arg0, arg1, vm)?,
            Self::JmpIfNullAcc(arg0, arg1) => instruction::jmp_if_null(arg0, arg1, vm)?,
            Self::JmpIfNullStack(arg0, arg1) => instruction::jmp_if_null(arg0, arg1, vm)?,
            Self::JmpIfNullConst(arg0, arg1) => instruction::jmp_if_null(arg0, arg1, vm)?,
            Self::JmpIfNullF32(arg0, arg1) => instruction::jmp_if_null(arg0, arg1, vm)?,
            Self::JmpIfNullI32(arg0, arg1) => instruction::jmp_if_null(arg0, arg1, vm)?,
            Self::JmpIfNullU32(arg0, arg1) => instruction::jmp_if_null(arg0, arg1, vm)?,
            Self::JmpIfNullBool(arg0, arg1) => instruction::jmp_if_null(arg0, arg1, vm)?,
            Self::JmpIfNullNull(arg0, arg1) => instruction::jmp_if_null(arg0, arg1, vm)?,
            Self::JmpIfNullUndefined(arg0, arg1) => {
                instruction::jmp_if_null(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullVar(arg0, arg1) => {
                instruction::jmp_if_not_null(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullReg(arg0, arg1) => {
                instruction::jmp_if_not_null(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullAcc(arg0, arg1) => {
                instruction::jmp_if_not_null(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullStack(arg0, arg1) => {
                instruction::jmp_if_not_null(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullConst(arg0, arg1) => {
                instruction::jmp_if_not_null(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullF32(arg0, arg1) => {
                instruction::jmp_if_not_null(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullI32(arg0, arg1) => {
                instruction::jmp_if_not_null(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullU32(arg0, arg1) => {
                instruction::jmp_if_not_null(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullBool(arg0, arg1) => {
                instruction::jmp_if_not_null(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullNull(arg0, arg1) => {
                instruction::jmp_if_not_null(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullUndefined(arg0, arg1) => {
                instruction::jmp_if_not_null(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedVar(arg0, arg1) => {
                instruction::jmp_if_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedReg(arg0, arg1) => {
                instruction::jmp_if_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedAcc(arg0, arg1) => {
                instruction::jmp_if_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedStack(arg0, arg1) => {
                instruction::jmp_if_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedConst(arg0, arg1) => {
                instruction::jmp_if_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedF32(arg0, arg1) => {
                instruction::jmp_if_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedI32(arg0, arg1) => {
                instruction::jmp_if_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedU32(arg0, arg1) => {
                instruction::jmp_if_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedBool(arg0, arg1) => {
                instruction::jmp_if_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedNull(arg0, arg1) => {
                instruction::jmp_if_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedUndefined(arg0, arg1) => {
                instruction::jmp_if_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedVar(arg0, arg1) => {
                instruction::jmp_if_not_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedReg(arg0, arg1) => {
                instruction::jmp_if_not_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedAcc(arg0, arg1) => {
                instruction::jmp_if_not_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedStack(arg0, arg1) => {
                instruction::jmp_if_not_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedConst(arg0, arg1) => {
                instruction::jmp_if_not_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedF32(arg0, arg1) => {
                instruction::jmp_if_not_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedI32(arg0, arg1) => {
                instruction::jmp_if_not_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedU32(arg0, arg1) => {
                instruction::jmp_if_not_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedBool(arg0, arg1) => {
                instruction::jmp_if_not_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedNull(arg0, arg1) => {
                instruction::jmp_if_not_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedUndefined(arg0, arg1) => {
                instruction::jmp_if_not_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNullishVar(arg0, arg1) => {
                instruction::jmp_if_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNullishReg(arg0, arg1) => {
                instruction::jmp_if_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNullishAcc(arg0, arg1) => {
                instruction::jmp_if_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNullishStack(arg0, arg1) => {
                instruction::jmp_if_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNullishConst(arg0, arg1) => {
                instruction::jmp_if_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNullishF32(arg0, arg1) => {
                instruction::jmp_if_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNullishI32(arg0, arg1) => {
                instruction::jmp_if_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNullishU32(arg0, arg1) => {
                instruction::jmp_if_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNullishBool(arg0, arg1) => {
                instruction::jmp_if_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNullishNull(arg0, arg1) => {
                instruction::jmp_if_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNullishUndefined(arg0, arg1) => {
                instruction::jmp_if_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishVar(arg0, arg1) => {
                instruction::jmp_if_not_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishReg(arg0, arg1) => {
                instruction::jmp_if_not_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishAcc(arg0, arg1) => {
                instruction::jmp_if_not_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishStack(arg0, arg1) => {
                instruction::jmp_if_not_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishConst(arg0, arg1) => {
                instruction::jmp_if_not_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishF32(arg0, arg1) => {
                instruction::jmp_if_not_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishI32(arg0, arg1) => {
                instruction::jmp_if_not_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishU32(arg0, arg1) => {
                instruction::jmp_if_not_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishBool(arg0, arg1) => {
                instruction::jmp_if_not_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishNull(arg0, arg1) => {
                instruction::jmp_if_not_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishUndefined(arg0, arg1) => {
                instruction::jmp_if_not_nullish(arg0, arg1, vm)?
            }
            Self::JmpRel(arg0) => instruction::jmp_rel(arg0, vm)?,
            Self::JmpIfRelVar(arg0, arg1) => instruction::jmp_if_rel(arg0, arg1, vm)?,
            Self::JmpIfRelReg(arg0, arg1) => instruction::jmp_if_rel(arg0, arg1, vm)?,
            Self::JmpIfRelAcc(arg0, arg1) => instruction::jmp_if_rel(arg0, arg1, vm)?,
            Self::JmpIfRelStack(arg0, arg1) => instruction::jmp_if_rel(arg0, arg1, vm)?,
            Self::JmpIfRelConst(arg0, arg1) => instruction::jmp_if_rel(arg0, arg1, vm)?,
            Self::JmpIfRelF32(arg0, arg1) => instruction::jmp_if_rel(arg0, arg1, vm)?,
            Self::JmpIfRelI32(arg0, arg1) => instruction::jmp_if_rel(arg0, arg1, vm)?,
            Self::JmpIfRelU32(arg0, arg1) => instruction::jmp_if_rel(arg0, arg1, vm)?,
            Self::JmpIfRelBool(arg0, arg1) => instruction::jmp_if_rel(arg0, arg1, vm)?,
            Self::JmpIfRelNull(arg0, arg1) => instruction::jmp_if_rel(arg0, arg1, vm)?,
            Self::JmpIfRelUndefined(arg0, arg1) => {
                instruction::jmp_if_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotRelVar(arg0, arg1) => {
                instruction::jmp_if_not_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotRelReg(arg0, arg1) => {
                instruction::jmp_if_not_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotRelAcc(arg0, arg1) => {
                instruction::jmp_if_not_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotRelStack(arg0, arg1) => {
                instruction::jmp_if_not_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotRelConst(arg0, arg1) => {
                instruction::jmp_if_not_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotRelF32(arg0, arg1) => {
                instruction::jmp_if_not_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotRelI32(arg0, arg1) => {
                instruction::jmp_if_not_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotRelU32(arg0, arg1) => {
                instruction::jmp_if_not_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotRelBool(arg0, arg1) => {
                instruction::jmp_if_not_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotRelNull(arg0, arg1) => {
                instruction::jmp_if_not_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotRelUndefined(arg0, arg1) => {
                instruction::jmp_if_not_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullRelVar(arg0, arg1) => {
                instruction::jmp_if_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullRelReg(arg0, arg1) => {
                instruction::jmp_if_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullRelAcc(arg0, arg1) => {
                instruction::jmp_if_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullRelStack(arg0, arg1) => {
                instruction::jmp_if_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullRelConst(arg0, arg1) => {
                instruction::jmp_if_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullRelF32(arg0, arg1) => {
                instruction::jmp_if_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullRelI32(arg0, arg1) => {
                instruction::jmp_if_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullRelU32(arg0, arg1) => {
                instruction::jmp_if_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullRelBool(arg0, arg1) => {
                instruction::jmp_if_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullRelNull(arg0, arg1) => {
                instruction::jmp_if_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullRelUndefined(arg0, arg1) => {
                instruction::jmp_if_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullRelVar(arg0, arg1) => {
                instruction::jmp_if_not_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullRelReg(arg0, arg1) => {
                instruction::jmp_if_not_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullRelAcc(arg0, arg1) => {
                instruction::jmp_if_not_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullRelStack(arg0, arg1) => {
                instruction::jmp_if_not_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullRelConst(arg0, arg1) => {
                instruction::jmp_if_not_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullRelF32(arg0, arg1) => {
                instruction::jmp_if_not_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullRelI32(arg0, arg1) => {
                instruction::jmp_if_not_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullRelU32(arg0, arg1) => {
                instruction::jmp_if_not_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullRelBool(arg0, arg1) => {
                instruction::jmp_if_not_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullRelNull(arg0, arg1) => {
                instruction::jmp_if_not_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullRelUndefined(arg0, arg1) => {
                instruction::jmp_if_not_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedRelVar(arg0, arg1) => {
                instruction::jmp_if_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedRelReg(arg0, arg1) => {
                instruction::jmp_if_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedRelAcc(arg0, arg1) => {
                instruction::jmp_if_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedRelStack(arg0, arg1) => {
                instruction::jmp_if_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedRelConst(arg0, arg1) => {
                instruction::jmp_if_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedRelF32(arg0, arg1) => {
                instruction::jmp_if_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedRelI32(arg0, arg1) => {
                instruction::jmp_if_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedRelU32(arg0, arg1) => {
                instruction::jmp_if_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedRelBool(arg0, arg1) => {
                instruction::jmp_if_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedRelNull(arg0, arg1) => {
                instruction::jmp_if_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedRelUndefined(arg0, arg1) => {
                instruction::jmp_if_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedRelVar(arg0, arg1) => {
                instruction::jmp_if_not_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedRelReg(arg0, arg1) => {
                instruction::jmp_if_not_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedRelAcc(arg0, arg1) => {
                instruction::jmp_if_not_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedRelStack(arg0, arg1) => {
                instruction::jmp_if_not_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedRelConst(arg0, arg1) => {
                instruction::jmp_if_not_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedRelF32(arg0, arg1) => {
                instruction::jmp_if_not_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedRelI32(arg0, arg1) => {
                instruction::jmp_if_not_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedRelU32(arg0, arg1) => {
                instruction::jmp_if_not_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedRelBool(arg0, arg1) => {
                instruction::jmp_if_not_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedRelNull(arg0, arg1) => {
                instruction::jmp_if_not_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedRelUndefined(arg0, arg1) => {
                instruction::jmp_if_not_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullishRelVar(arg0, arg1) => {
                instruction::jmp_if_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullishRelReg(arg0, arg1) => {
                instruction::jmp_if_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullishRelAcc(arg0, arg1) => {
                instruction::jmp_if_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullishRelStack(arg0, arg1) => {
                instruction::jmp_if_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullishRelConst(arg0, arg1) => {
                instruction::jmp_if_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullishRelF32(arg0, arg1) => {
                instruction::jmp_if_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullishRelI32(arg0, arg1) => {
                instruction::jmp_if_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullishRelU32(arg0, arg1) => {
                instruction::jmp_if_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullishRelBool(arg0, arg1) => {
                instruction::jmp_if_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullishRelNull(arg0, arg1) => {
                instruction::jmp_if_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullishRelUndefined(arg0, arg1) => {
                instruction::jmp_if_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishRelVar(arg0, arg1) => {
                instruction::jmp_if_not_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishRelReg(arg0, arg1) => {
                instruction::jmp_if_not_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishRelAcc(arg0, arg1) => {
                instruction::jmp_if_not_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishRelStack(arg0, arg1) => {
                instruction::jmp_if_not_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishRelConst(arg0, arg1) => {
                instruction::jmp_if_not_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishRelF32(arg0, arg1) => {
                instruction::jmp_if_not_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishRelI32(arg0, arg1) => {
                instruction::jmp_if_not_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishRelU32(arg0, arg1) => {
                instruction::jmp_if_not_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishRelBool(arg0, arg1) => {
                instruction::jmp_if_not_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishRelNull(arg0, arg1) => {
                instruction::jmp_if_not_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishRelUndefined(arg0, arg1) => {
                instruction::jmp_if_not_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfEqVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRelUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRelUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRelUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRelUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRelUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRelUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRelUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelVarVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelRegVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelAccVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelStackVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelConstVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelF32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelI32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelU32Var(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelBoolVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelNullVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelUndefinedVar(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelVarReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelRegReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelAccReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelStackReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelConstReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelF32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelI32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelU32Reg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelBoolReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelNullReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelUndefinedReg(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelVarAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelRegAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelAccAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelStackAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelConstAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelF32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelI32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelU32Acc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelBoolAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelNullAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelUndefinedAcc(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelVarStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelRegStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelAccStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelStackStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelConstStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelF32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelI32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelU32Stack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelBoolStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelNullStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelUndefinedStack(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelVarConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelRegConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelAccConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelStackConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelConstConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelF32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelI32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelU32Const(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelBoolConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelNullConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelUndefinedConst(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelVarF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelRegF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelAccF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelStackF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelConstF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelF32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelI32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelU32F32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelBoolF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelNullF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelUndefinedF32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelVarI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelRegI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelAccI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelStackI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelConstI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelF32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelI32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelU32I32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelBoolI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelNullI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelUndefinedI32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelVarU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelRegU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelAccU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelStackU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelConstU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelF32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelI32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelU32U32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelBoolU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelNullU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelUndefinedU32(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelVarBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelRegBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelAccBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelStackBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelConstBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelF32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelI32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelU32Bool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelBoolBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelNullBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelUndefinedBool(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelVarNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelRegNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelAccNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelStackNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelConstNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelF32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelI32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelU32Null(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelBoolNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelNullNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelUndefinedNull(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelVarUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelRegUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelAccUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelStackUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelConstUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelF32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelI32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelU32Undefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelBoolUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelNullUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRelUndefinedUndefined(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::LoadMemberVarVarToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegVarToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccVarToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackVarToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstVarToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32VarToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32VarToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32VarToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolVarToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullVarToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedVarToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarRegToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegRegToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccRegToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackRegToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstRegToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32RegToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32RegToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32RegToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolRegToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullRegToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedRegToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarAccToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegAccToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccAccToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackAccToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstAccToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32AccToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32AccToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32AccToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolAccToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullAccToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedAccToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarStackToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegStackToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccStackToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackStackToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstStackToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32StackToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32StackToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32StackToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolStackToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullStackToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedStackToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarConstToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegConstToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccConstToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackConstToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstConstToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32ConstToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32ConstToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32ConstToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolConstToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullConstToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedConstToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarF32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegF32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccF32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackF32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstF32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32F32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32F32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32F32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolF32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullF32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedF32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarI32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegI32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccI32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackI32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstI32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32I32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32I32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32I32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolI32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullI32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedI32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarU32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegU32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccU32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackU32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstU32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32U32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32U32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32U32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolU32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullU32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedU32ToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarBoolToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegBoolToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccBoolToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackBoolToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstBoolToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32BoolToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32BoolToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32BoolToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolBoolToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullBoolToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedBoolToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarNullToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegNullToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccNullToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackNullToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstNullToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32NullToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32NullToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32NullToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolNullToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullNullToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedNullToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarUndefinedToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegUndefinedToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccUndefinedToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackUndefinedToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstUndefinedToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32UndefinedToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32UndefinedToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32UndefinedToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolUndefinedToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullUndefinedToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedUndefinedToVar(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarVarToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegVarToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccVarToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackVarToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstVarToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32VarToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32VarToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32VarToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolVarToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullVarToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedVarToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarRegToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegRegToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccRegToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackRegToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstRegToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32RegToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32RegToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32RegToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolRegToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullRegToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedRegToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarAccToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegAccToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccAccToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackAccToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstAccToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32AccToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32AccToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32AccToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolAccToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullAccToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedAccToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarStackToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegStackToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccStackToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackStackToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstStackToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32StackToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32StackToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32StackToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolStackToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullStackToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedStackToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarConstToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegConstToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccConstToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackConstToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstConstToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32ConstToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32ConstToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32ConstToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolConstToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullConstToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedConstToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarF32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegF32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccF32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackF32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstF32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32F32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32F32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32F32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolF32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullF32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedF32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarI32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegI32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccI32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackI32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstI32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32I32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32I32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32I32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolI32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullI32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedI32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarU32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegU32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccU32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackU32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstU32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32U32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32U32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32U32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolU32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullU32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedU32ToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarBoolToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegBoolToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccBoolToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackBoolToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstBoolToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32BoolToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32BoolToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32BoolToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolBoolToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullBoolToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedBoolToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarNullToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegNullToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccNullToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackNullToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstNullToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32NullToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32NullToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32NullToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolNullToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullNullToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedNullToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarUndefinedToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegUndefinedToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccUndefinedToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackUndefinedToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstUndefinedToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32UndefinedToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32UndefinedToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32UndefinedToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolUndefinedToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullUndefinedToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedUndefinedToReg(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarVarToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegVarToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccVarToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackVarToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstVarToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32VarToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32VarToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32VarToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolVarToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullVarToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedVarToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarRegToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegRegToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccRegToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackRegToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstRegToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32RegToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32RegToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32RegToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolRegToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullRegToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedRegToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarAccToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegAccToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccAccToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackAccToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstAccToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32AccToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32AccToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32AccToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolAccToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullAccToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedAccToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarStackToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegStackToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccStackToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackStackToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstStackToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32StackToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32StackToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32StackToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolStackToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullStackToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedStackToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarConstToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegConstToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccConstToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackConstToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstConstToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32ConstToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32ConstToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32ConstToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolConstToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullConstToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedConstToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarF32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegF32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccF32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackF32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstF32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32F32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32F32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32F32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolF32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullF32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedF32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarI32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegI32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccI32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackI32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstI32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32I32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32I32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32I32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolI32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullI32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedI32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarU32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegU32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccU32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackU32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstU32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32U32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32U32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32U32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolU32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullU32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedU32ToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarBoolToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegBoolToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccBoolToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackBoolToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstBoolToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32BoolToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32BoolToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32BoolToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolBoolToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullBoolToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedBoolToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarNullToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegNullToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccNullToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackNullToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstNullToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32NullToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32NullToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32NullToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolNullToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullNullToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedNullToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarUndefinedToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegUndefinedToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccUndefinedToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackUndefinedToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstUndefinedToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32UndefinedToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32UndefinedToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32UndefinedToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolUndefinedToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullUndefinedToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedUndefinedToAcc(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarVarToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegVarToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccVarToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackVarToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstVarToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32VarToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32VarToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32VarToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolVarToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullVarToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedVarToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarRegToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegRegToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccRegToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackRegToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstRegToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32RegToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32RegToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32RegToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolRegToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullRegToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedRegToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarAccToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegAccToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccAccToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackAccToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstAccToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32AccToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32AccToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32AccToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolAccToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullAccToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedAccToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarStackToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegStackToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccStackToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackStackToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstStackToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32StackToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32StackToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32StackToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolStackToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullStackToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedStackToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarConstToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegConstToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccConstToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackConstToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstConstToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32ConstToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32ConstToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32ConstToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolConstToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullConstToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedConstToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarF32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegF32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccF32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackF32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstF32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32F32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32F32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32F32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolF32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullF32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedF32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarI32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegI32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccI32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackI32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstI32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32I32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32I32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32I32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolI32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullI32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedI32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarU32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegU32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccU32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackU32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstU32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32U32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32U32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32U32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolU32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullU32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedU32ToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarBoolToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegBoolToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccBoolToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackBoolToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstBoolToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32BoolToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32BoolToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32BoolToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolBoolToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullBoolToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedBoolToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarNullToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegNullToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccNullToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackNullToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstNullToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32NullToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32NullToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32NullToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolNullToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullNullToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedNullToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberVarUndefinedToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberRegUndefinedToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberAccUndefinedToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberStackUndefinedToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberConstUndefinedToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberF32UndefinedToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberI32UndefinedToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberU32UndefinedToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberBoolUndefinedToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberNullUndefinedToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadMemberUndefinedUndefinedToStack(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadVarVarToVar(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarRegToVar(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarAccToVar(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarStackToVar(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarConstToVar(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarF32ToVar(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarI32ToVar(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarU32ToVar(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarBoolToVar(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarNullToVar(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarUndefinedToVar(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarVarToReg(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarRegToReg(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarAccToReg(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarStackToReg(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarConstToReg(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarF32ToReg(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarI32ToReg(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarU32ToReg(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarBoolToReg(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarNullToReg(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarUndefinedToReg(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarVarToAcc(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarRegToAcc(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarAccToAcc(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarStackToAcc(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarConstToAcc(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarF32ToAcc(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarI32ToAcc(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarU32ToAcc(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarBoolToAcc(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarNullToAcc(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarUndefinedToAcc(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarVarToStack(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarRegToStack(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarAccToStack(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarStackToStack(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarConstToStack(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarF32ToStack(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarI32ToStack(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarU32ToStack(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarBoolToStack(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarNullToStack(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::LoadVarUndefinedToStack(arg0, output) => {
                instruction::load_var(arg0, output, vm)?
            }
            Self::TypeOfVarToVar(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfRegToVar(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfAccToVar(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfStackToVar(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfConstToVar(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfF32ToVar(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfI32ToVar(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfU32ToVar(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfBoolToVar(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfNullToVar(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfUndefinedToVar(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfVarToReg(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfRegToReg(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfAccToReg(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfStackToReg(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfConstToReg(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfF32ToReg(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfI32ToReg(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfU32ToReg(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfBoolToReg(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfNullToReg(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfUndefinedToReg(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfVarToAcc(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfRegToAcc(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfAccToAcc(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfStackToAcc(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfConstToAcc(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfF32ToAcc(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfI32ToAcc(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfU32ToAcc(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::TypeOfBoolToAcc(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfNullToAcc(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfUndefinedToAcc(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfVarToStack(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfRegToStack(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfAccToStack(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfStackToStack(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfConstToStack(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfF32ToStack(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfI32ToStack(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfU32ToStack(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfBoolToStack(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfNullToStack(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::TypeOfUndefinedToStack(arg0, output) => {
                instruction::type_of(arg0, output, vm)?
            }
            Self::PushVar(arg0) => instruction::push(arg0, vm)?,
            Self::PushReg(arg0) => instruction::push(arg0, vm)?,
            Self::PushAcc(arg0) => instruction::push(arg0, vm)?,
            Self::PushStack(arg0) => instruction::push(arg0, vm)?,
            Self::PushConst(arg0) => instruction::push(arg0, vm)?,
            Self::PushF32(arg0) => instruction::push(arg0, vm)?,
            Self::PushI32(arg0) => instruction::push(arg0, vm)?,
            Self::PushU32(arg0) => instruction::push(arg0, vm)?,
            Self::PushBool(arg0) => instruction::push(arg0, vm)?,
            Self::PushNull(arg0) => instruction::push(arg0, vm)?,
            Self::PushUndefined(arg0) => instruction::push(arg0, vm)?,
            Self::Pop => instruction::pop(vm)?,
            Self::PopN(arg0) => instruction::pop_n(arg0, vm)?,
            Self::PopToToVar(output) => instruction::pop_to(output, vm)?,
            Self::PopToToReg(output) => instruction::pop_to(output, vm)?,
            Self::PopToToAcc(output) => instruction::pop_to(output, vm)?,
            Self::PopToToStack(output) => instruction::pop_to(output, vm)?,
            Self::MoveVarToVar(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveRegToVar(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveAccToVar(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveStackToVar(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveConstToVar(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveF32ToVar(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveI32ToVar(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveU32ToVar(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveBoolToVar(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveNullToVar(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveUndefinedToVar(arg0, output) => {
                instruction::move_(arg0, output, vm)?
            }
            Self::MoveVarToReg(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveRegToReg(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveAccToReg(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveStackToReg(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveConstToReg(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveF32ToReg(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveI32ToReg(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveU32ToReg(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveBoolToReg(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveNullToReg(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveUndefinedToReg(arg0, output) => {
                instruction::move_(arg0, output, vm)?
            }
            Self::MoveVarToAcc(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveRegToAcc(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveAccToAcc(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveStackToAcc(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveConstToAcc(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveF32ToAcc(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveI32ToAcc(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveU32ToAcc(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveBoolToAcc(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveNullToAcc(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveUndefinedToAcc(arg0, output) => {
                instruction::move_(arg0, output, vm)?
            }
            Self::MoveVarToStack(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveRegToStack(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveAccToStack(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveStackToStack(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveConstToStack(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveF32ToStack(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveI32ToStack(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveU32ToStack(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveBoolToStack(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveNullToStack(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::MoveUndefinedToStack(arg0, output) => {
                instruction::move_(arg0, output, vm)?
            }
            Self::Return => instruction::return_(vm)?,
            Self::ReturnValueVar(arg0) => instruction::return_value(arg0, vm)?,
            Self::ReturnValueReg(arg0) => instruction::return_value(arg0, vm)?,
            Self::ReturnValueAcc(arg0) => instruction::return_value(arg0, vm)?,
            Self::ReturnValueStack(arg0) => instruction::return_value(arg0, vm)?,
            Self::ReturnValueConst(arg0) => instruction::return_value(arg0, vm)?,
            Self::ReturnValueF32(arg0) => instruction::return_value(arg0, vm)?,
            Self::ReturnValueI32(arg0) => instruction::return_value(arg0, vm)?,
            Self::ReturnValueU32(arg0) => instruction::return_value(arg0, vm)?,
            Self::ReturnValueBool(arg0) => instruction::return_value(arg0, vm)?,
            Self::ReturnValueNull(arg0) => instruction::return_value(arg0, vm)?,
            Self::ReturnValueUndefined(arg0) => instruction::return_value(arg0, vm)?,
            Self::Break => instruction::break_(vm)?,
            Self::BreakLabel(arg0) => instruction::break_label(arg0, vm)?,
            Self::Continue => instruction::continue_(vm)?,
            Self::ContinueLabel(arg0) => instruction::continue_label(arg0, vm)?,
            Self::ThrowVar(arg0) => instruction::throw(arg0, vm)?,
            Self::ThrowReg(arg0) => instruction::throw(arg0, vm)?,
            Self::ThrowAcc(arg0) => instruction::throw(arg0, vm)?,
            Self::ThrowStack(arg0) => instruction::throw(arg0, vm)?,
            Self::ThrowConst(arg0) => instruction::throw(arg0, vm)?,
            Self::ThrowF32(arg0) => instruction::throw(arg0, vm)?,
            Self::ThrowI32(arg0) => instruction::throw(arg0, vm)?,
            Self::ThrowU32(arg0) => instruction::throw(arg0, vm)?,
            Self::ThrowBool(arg0) => instruction::throw(arg0, vm)?,
            Self::ThrowNull(arg0) => instruction::throw(arg0, vm)?,
            Self::ThrowUndefined(arg0) => instruction::throw(arg0, vm)?,
            Self::ThisToVar(output) => instruction::this(output, vm)?,
            Self::ThisToReg(output) => instruction::this(output, vm)?,
            Self::ThisToAcc(output) => instruction::this(output, vm)?,
            Self::ThisToStack(output) => instruction::this(output, vm)?,
            Self::LoadSuperToVar(output) => instruction::load_super(output, vm)?,
            Self::LoadSuperToReg(output) => instruction::load_super(output, vm)?,
            Self::LoadSuperToAcc(output) => instruction::load_super(output, vm)?,
            Self::LoadSuperToStack(output) => instruction::load_super(output, vm)?,
            Self::LoadSuperConstructorToVar(output) => {
                instruction::load_super_constructor(output, vm)?
            }
            Self::LoadSuperConstructorToReg(output) => {
                instruction::load_super_constructor(output, vm)?
            }
            Self::LoadSuperConstructorToAcc(output) => {
                instruction::load_super_constructor(output, vm)?
            }
            Self::LoadSuperConstructorToStack(output) => {
                instruction::load_super_constructor(output, vm)?
            }
            Self::YieldVar(arg0) => instruction::yield_(arg0, vm)?,
            Self::YieldReg(arg0) => instruction::yield_(arg0, vm)?,
            Self::YieldAcc(arg0) => instruction::yield_(arg0, vm)?,
            Self::YieldStack(arg0) => instruction::yield_(arg0, vm)?,
            Self::YieldConst(arg0) => instruction::yield_(arg0, vm)?,
            Self::YieldF32(arg0) => instruction::yield_(arg0, vm)?,
            Self::YieldI32(arg0) => instruction::yield_(arg0, vm)?,
            Self::YieldU32(arg0) => instruction::yield_(arg0, vm)?,
            Self::YieldBool(arg0) => instruction::yield_(arg0, vm)?,
            Self::YieldNull(arg0) => instruction::yield_(arg0, vm)?,
            Self::YieldUndefined(arg0) => instruction::yield_(arg0, vm)?,
            Self::YieldUndefined => instruction::yield_undefined(vm)?,
            Self::AwaitVarToVar(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitRegToVar(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitAccToVar(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitStackToVar(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitConstToVar(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitF32ToVar(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitI32ToVar(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitU32ToVar(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitBoolToVar(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitNullToVar(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitUndefinedToVar(arg0, output) => {
                instruction::await_(arg0, output, vm)?
            }
            Self::AwaitVarToReg(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitRegToReg(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitAccToReg(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitStackToReg(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitConstToReg(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitF32ToReg(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitI32ToReg(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitU32ToReg(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitBoolToReg(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitNullToReg(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitUndefinedToReg(arg0, output) => {
                instruction::await_(arg0, output, vm)?
            }
            Self::AwaitVarToAcc(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitRegToAcc(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitAccToAcc(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitStackToAcc(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitConstToAcc(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitF32ToAcc(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitI32ToAcc(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitU32ToAcc(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitBoolToAcc(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitNullToAcc(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitUndefinedToAcc(arg0, output) => {
                instruction::await_(arg0, output, vm)?
            }
            Self::AwaitVarToStack(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitRegToStack(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitAccToStack(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitStackToStack(arg0, output) => {
                instruction::await_(arg0, output, vm)?
            }
            Self::AwaitConstToStack(arg0, output) => {
                instruction::await_(arg0, output, vm)?
            }
            Self::AwaitF32ToStack(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitI32ToStack(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitU32ToStack(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitBoolToStack(arg0, output) => {
                instruction::await_(arg0, output, vm)?
            }
            Self::AwaitNullToStack(arg0, output) => {
                instruction::await_(arg0, output, vm)?
            }
            Self::AwaitUndefinedToStack(arg0, output) => {
                instruction::await_(arg0, output, vm)?
            }
            Self::AwaitNoOutputVar(arg0) => instruction::await_no_output(arg0, vm)?,
            Self::AwaitNoOutputReg(arg0) => instruction::await_no_output(arg0, vm)?,
            Self::AwaitNoOutputAcc(arg0) => instruction::await_no_output(arg0, vm)?,
            Self::AwaitNoOutputStack(arg0) => instruction::await_no_output(arg0, vm)?,
            Self::AwaitNoOutputConst(arg0) => instruction::await_no_output(arg0, vm)?,
            Self::AwaitNoOutputF32(arg0) => instruction::await_no_output(arg0, vm)?,
            Self::AwaitNoOutputI32(arg0) => instruction::await_no_output(arg0, vm)?,
            Self::AwaitNoOutputU32(arg0) => instruction::await_no_output(arg0, vm)?,
            Self::AwaitNoOutputBool(arg0) => instruction::await_no_output(arg0, vm)?,
            Self::AwaitNoOutputNull(arg0) => instruction::await_no_output(arg0, vm)?,
            Self::AwaitNoOutputUndefined(arg0) => instruction::await_no_output(arg0, vm)?,
            Self::Debugger => instruction::debugger(vm)?,
            Self::WithVar(arg0) => instruction::with(arg0, vm)?,
            Self::WithReg(arg0) => instruction::with(arg0, vm)?,
            Self::WithAcc(arg0) => instruction::with(arg0, vm)?,
            Self::WithStack(arg0) => instruction::with(arg0, vm)?,
            Self::WithConst(arg0) => instruction::with(arg0, vm)?,
            Self::WithF32(arg0) => instruction::with(arg0, vm)?,
            Self::WithI32(arg0) => instruction::with(arg0, vm)?,
            Self::WithU32(arg0) => instruction::with(arg0, vm)?,
            Self::WithBool(arg0) => instruction::with(arg0, vm)?,
            Self::WithNull(arg0) => instruction::with(arg0, vm)?,
            Self::WithUndefined(arg0) => instruction::with(arg0, vm)?,
            Self::EnterTry(arg0) => instruction::enter_try(arg0, vm)?,
            Self::LeaveTry => instruction::leave_try(vm)?,
            Self::AddAssignVarToVar(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignRegToVar(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignAccToVar(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignStackToVar(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignConstToVar(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignF32ToVar(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignI32ToVar(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignU32ToVar(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignBoolToVar(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignNullToVar(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignUndefinedToVar(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignVarToReg(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignRegToReg(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignAccToReg(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignStackToReg(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignConstToReg(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignF32ToReg(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignI32ToReg(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignU32ToReg(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignBoolToReg(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignNullToReg(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignUndefinedToReg(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignVarToAcc(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignRegToAcc(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignAccToAcc(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignStackToAcc(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignConstToAcc(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignF32ToAcc(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignI32ToAcc(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignU32ToAcc(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignBoolToAcc(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignNullToAcc(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignUndefinedToAcc(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignVarToStack(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignRegToStack(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignAccToStack(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignStackToStack(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignConstToStack(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignF32ToStack(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignI32ToStack(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignU32ToStack(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignBoolToStack(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignNullToStack(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::AddAssignUndefinedToStack(arg0, output) => {
                instruction::add_assign(arg0, output, vm)?
            }
            Self::SubAssignVarToVar(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignRegToVar(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignAccToVar(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignStackToVar(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignConstToVar(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignF32ToVar(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignI32ToVar(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignU32ToVar(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignBoolToVar(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignNullToVar(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignUndefinedToVar(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignVarToReg(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignRegToReg(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignAccToReg(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignStackToReg(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignConstToReg(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignF32ToReg(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignI32ToReg(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignU32ToReg(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignBoolToReg(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignNullToReg(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignUndefinedToReg(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignVarToAcc(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignRegToAcc(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignAccToAcc(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignStackToAcc(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignConstToAcc(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignF32ToAcc(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignI32ToAcc(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignU32ToAcc(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignBoolToAcc(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignNullToAcc(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignUndefinedToAcc(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignVarToStack(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignRegToStack(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignAccToStack(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignStackToStack(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignConstToStack(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignF32ToStack(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignI32ToStack(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignU32ToStack(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignBoolToStack(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignNullToStack(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::SubAssignUndefinedToStack(arg0, output) => {
                instruction::sub_assign(arg0, output, vm)?
            }
            Self::MulAssignVarToVar(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignRegToVar(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignAccToVar(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignStackToVar(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignConstToVar(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignF32ToVar(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignI32ToVar(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignU32ToVar(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignBoolToVar(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignNullToVar(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignUndefinedToVar(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignVarToReg(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignRegToReg(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignAccToReg(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignStackToReg(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignConstToReg(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignF32ToReg(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignI32ToReg(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignU32ToReg(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignBoolToReg(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignNullToReg(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignUndefinedToReg(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignVarToAcc(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignRegToAcc(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignAccToAcc(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignStackToAcc(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignConstToAcc(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignF32ToAcc(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignI32ToAcc(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignU32ToAcc(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignBoolToAcc(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignNullToAcc(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignUndefinedToAcc(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignVarToStack(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignRegToStack(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignAccToStack(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignStackToStack(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignConstToStack(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignF32ToStack(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignI32ToStack(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignU32ToStack(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignBoolToStack(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignNullToStack(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::MulAssignUndefinedToStack(arg0, output) => {
                instruction::mul_assign(arg0, output, vm)?
            }
            Self::DivAssignVarToVar(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignRegToVar(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignAccToVar(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignStackToVar(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignConstToVar(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignF32ToVar(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignI32ToVar(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignU32ToVar(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignBoolToVar(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignNullToVar(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignUndefinedToVar(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignVarToReg(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignRegToReg(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignAccToReg(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignStackToReg(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignConstToReg(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignF32ToReg(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignI32ToReg(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignU32ToReg(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignBoolToReg(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignNullToReg(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignUndefinedToReg(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignVarToAcc(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignRegToAcc(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignAccToAcc(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignStackToAcc(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignConstToAcc(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignF32ToAcc(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignI32ToAcc(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignU32ToAcc(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignBoolToAcc(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignNullToAcc(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignUndefinedToAcc(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignVarToStack(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignRegToStack(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignAccToStack(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignStackToStack(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignConstToStack(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignF32ToStack(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignI32ToStack(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignU32ToStack(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignBoolToStack(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignNullToStack(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::DivAssignUndefinedToStack(arg0, output) => {
                instruction::div_assign(arg0, output, vm)?
            }
            Self::RemAssignVarToVar(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignRegToVar(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignAccToVar(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignStackToVar(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignConstToVar(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignF32ToVar(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignI32ToVar(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignU32ToVar(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignBoolToVar(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignNullToVar(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignUndefinedToVar(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignVarToReg(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignRegToReg(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignAccToReg(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignStackToReg(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignConstToReg(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignF32ToReg(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignI32ToReg(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignU32ToReg(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignBoolToReg(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignNullToReg(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignUndefinedToReg(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignVarToAcc(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignRegToAcc(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignAccToAcc(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignStackToAcc(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignConstToAcc(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignF32ToAcc(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignI32ToAcc(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignU32ToAcc(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignBoolToAcc(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignNullToAcc(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignUndefinedToAcc(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignVarToStack(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignRegToStack(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignAccToStack(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignStackToStack(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignConstToStack(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignF32ToStack(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignI32ToStack(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignU32ToStack(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignBoolToStack(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignNullToStack(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::RemAssignUndefinedToStack(arg0, output) => {
                instruction::rem_assign(arg0, output, vm)?
            }
            Self::LShiftAssignVarToVar(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignRegToVar(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignAccToVar(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignStackToVar(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignConstToVar(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignF32ToVar(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignI32ToVar(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignU32ToVar(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignBoolToVar(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignNullToVar(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignUndefinedToVar(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignVarToReg(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignRegToReg(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignAccToReg(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignStackToReg(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignConstToReg(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignF32ToReg(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignI32ToReg(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignU32ToReg(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignBoolToReg(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignNullToReg(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignUndefinedToReg(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignVarToAcc(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignRegToAcc(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignAccToAcc(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignStackToAcc(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignConstToAcc(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignF32ToAcc(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignI32ToAcc(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignU32ToAcc(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignBoolToAcc(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignNullToAcc(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignUndefinedToAcc(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignVarToStack(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignRegToStack(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignAccToStack(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignStackToStack(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignConstToStack(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignF32ToStack(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignI32ToStack(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignU32ToStack(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignBoolToStack(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignNullToStack(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::LShiftAssignUndefinedToStack(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignVarToVar(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignRegToVar(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignAccToVar(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignStackToVar(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignConstToVar(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignF32ToVar(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignI32ToVar(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignU32ToVar(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignBoolToVar(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignNullToVar(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignUndefinedToVar(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignVarToReg(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignRegToReg(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignAccToReg(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignStackToReg(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignConstToReg(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignF32ToReg(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignI32ToReg(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignU32ToReg(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignBoolToReg(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignNullToReg(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignUndefinedToReg(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignVarToAcc(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignRegToAcc(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignAccToAcc(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignStackToAcc(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignConstToAcc(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignF32ToAcc(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignI32ToAcc(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignU32ToAcc(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignBoolToAcc(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignNullToAcc(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignUndefinedToAcc(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignVarToStack(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignRegToStack(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignAccToStack(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignStackToStack(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignConstToStack(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignF32ToStack(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignI32ToStack(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignU32ToStack(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignBoolToStack(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignNullToStack(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssignUndefinedToStack(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignVarToVar(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignRegToVar(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignAccToVar(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignStackToVar(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignConstToVar(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignF32ToVar(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignI32ToVar(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignU32ToVar(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignBoolToVar(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignNullToVar(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignUndefinedToVar(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignVarToReg(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignRegToReg(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignAccToReg(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignStackToReg(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignConstToReg(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignF32ToReg(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignI32ToReg(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignU32ToReg(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignBoolToReg(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignNullToReg(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignUndefinedToReg(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignVarToAcc(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignRegToAcc(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignAccToAcc(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignStackToAcc(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignConstToAcc(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignF32ToAcc(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignI32ToAcc(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignU32ToAcc(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignBoolToAcc(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignNullToAcc(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignUndefinedToAcc(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignVarToStack(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignRegToStack(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignAccToStack(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignStackToStack(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignConstToStack(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignF32ToStack(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignI32ToStack(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignU32ToStack(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignBoolToStack(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignNullToStack(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssignUndefinedToStack(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::BAndAssignVarToVar(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignRegToVar(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignAccToVar(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignStackToVar(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignConstToVar(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignF32ToVar(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignI32ToVar(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignU32ToVar(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignBoolToVar(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignNullToVar(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignUndefinedToVar(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignVarToReg(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignRegToReg(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignAccToReg(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignStackToReg(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignConstToReg(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignF32ToReg(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignI32ToReg(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignU32ToReg(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignBoolToReg(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignNullToReg(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignUndefinedToReg(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignVarToAcc(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignRegToAcc(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignAccToAcc(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignStackToAcc(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignConstToAcc(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignF32ToAcc(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignI32ToAcc(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignU32ToAcc(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignBoolToAcc(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignNullToAcc(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignUndefinedToAcc(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignVarToStack(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignRegToStack(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignAccToStack(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignStackToStack(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignConstToStack(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignF32ToStack(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignI32ToStack(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignU32ToStack(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignBoolToStack(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignNullToStack(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BAndAssignUndefinedToStack(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BOrAssignVarToVar(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignRegToVar(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignAccToVar(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignStackToVar(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignConstToVar(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignF32ToVar(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignI32ToVar(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignU32ToVar(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignBoolToVar(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignNullToVar(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignUndefinedToVar(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignVarToReg(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignRegToReg(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignAccToReg(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignStackToReg(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignConstToReg(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignF32ToReg(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignI32ToReg(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignU32ToReg(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignBoolToReg(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignNullToReg(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignUndefinedToReg(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignVarToAcc(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignRegToAcc(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignAccToAcc(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignStackToAcc(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignConstToAcc(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignF32ToAcc(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignI32ToAcc(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignU32ToAcc(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignBoolToAcc(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignNullToAcc(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignUndefinedToAcc(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignVarToStack(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignRegToStack(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignAccToStack(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignStackToStack(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignConstToStack(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignF32ToStack(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignI32ToStack(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignU32ToStack(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignBoolToStack(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignNullToStack(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BOrAssignUndefinedToStack(arg0, output) => {
                instruction::b_or_assign(arg0, output, vm)?
            }
            Self::BXorAssignVarToVar(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignRegToVar(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignAccToVar(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignStackToVar(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignConstToVar(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignF32ToVar(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignI32ToVar(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignU32ToVar(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignBoolToVar(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignNullToVar(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignUndefinedToVar(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignVarToReg(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignRegToReg(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignAccToReg(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignStackToReg(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignConstToReg(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignF32ToReg(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignI32ToReg(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignU32ToReg(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignBoolToReg(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignNullToReg(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignUndefinedToReg(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignVarToAcc(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignRegToAcc(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignAccToAcc(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignStackToAcc(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignConstToAcc(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignF32ToAcc(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignI32ToAcc(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignU32ToAcc(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignBoolToAcc(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignNullToAcc(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignUndefinedToAcc(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignVarToStack(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignRegToStack(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignAccToStack(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignStackToStack(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignConstToStack(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignF32ToStack(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignI32ToStack(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignU32ToStack(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignBoolToStack(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignNullToStack(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::BXorAssignUndefinedToStack(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::ExpAssignVarToVar(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignRegToVar(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignAccToVar(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignStackToVar(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignConstToVar(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignF32ToVar(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignI32ToVar(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignU32ToVar(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignBoolToVar(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignNullToVar(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignUndefinedToVar(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignVarToReg(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignRegToReg(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignAccToReg(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignStackToReg(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignConstToReg(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignF32ToReg(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignI32ToReg(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignU32ToReg(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignBoolToReg(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignNullToReg(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignUndefinedToReg(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignVarToAcc(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignRegToAcc(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignAccToAcc(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignStackToAcc(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignConstToAcc(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignF32ToAcc(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignI32ToAcc(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignU32ToAcc(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignBoolToAcc(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignNullToAcc(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignUndefinedToAcc(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignVarToStack(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignRegToStack(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignAccToStack(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignStackToStack(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignConstToStack(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignF32ToStack(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignI32ToStack(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignU32ToStack(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignBoolToStack(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignNullToStack(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::ExpAssignUndefinedToStack(arg0, output) => {
                instruction::exp_assign(arg0, output, vm)?
            }
            Self::AndAssignVarToVar(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignRegToVar(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignAccToVar(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignStackToVar(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignConstToVar(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignF32ToVar(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignI32ToVar(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignU32ToVar(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignBoolToVar(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignNullToVar(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignUndefinedToVar(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignVarToReg(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignRegToReg(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignAccToReg(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignStackToReg(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignConstToReg(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignF32ToReg(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignI32ToReg(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignU32ToReg(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignBoolToReg(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignNullToReg(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignUndefinedToReg(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignVarToAcc(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignRegToAcc(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignAccToAcc(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignStackToAcc(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignConstToAcc(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignF32ToAcc(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignI32ToAcc(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignU32ToAcc(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignBoolToAcc(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignNullToAcc(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignUndefinedToAcc(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignVarToStack(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignRegToStack(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignAccToStack(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignStackToStack(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignConstToStack(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignF32ToStack(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignI32ToStack(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignU32ToStack(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignBoolToStack(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignNullToStack(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::AndAssignUndefinedToStack(arg0, output) => {
                instruction::and_assign(arg0, output, vm)?
            }
            Self::OrAssignVarToVar(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignRegToVar(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignAccToVar(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignStackToVar(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignConstToVar(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignF32ToVar(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignI32ToVar(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignU32ToVar(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignBoolToVar(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignNullToVar(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignUndefinedToVar(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignVarToReg(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignRegToReg(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignAccToReg(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignStackToReg(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignConstToReg(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignF32ToReg(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignI32ToReg(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignU32ToReg(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignBoolToReg(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignNullToReg(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignUndefinedToReg(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignVarToAcc(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignRegToAcc(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignAccToAcc(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignStackToAcc(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignConstToAcc(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignF32ToAcc(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignI32ToAcc(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignU32ToAcc(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignBoolToAcc(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignNullToAcc(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignUndefinedToAcc(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignVarToStack(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignRegToStack(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignAccToStack(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignStackToStack(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignConstToStack(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignF32ToStack(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignI32ToStack(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignU32ToStack(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignBoolToStack(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignNullToStack(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::OrAssignUndefinedToStack(arg0, output) => {
                instruction::or_assign(arg0, output, vm)?
            }
            Self::NullishAssignVarToVar(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignRegToVar(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignAccToVar(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignStackToVar(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignConstToVar(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignF32ToVar(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignI32ToVar(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignU32ToVar(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignBoolToVar(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignNullToVar(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignUndefinedToVar(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignVarToReg(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignRegToReg(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignAccToReg(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignStackToReg(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignConstToReg(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignF32ToReg(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignI32ToReg(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignU32ToReg(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignBoolToReg(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignNullToReg(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignUndefinedToReg(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignVarToAcc(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignRegToAcc(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignAccToAcc(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignStackToAcc(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignConstToAcc(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignF32ToAcc(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignI32ToAcc(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignU32ToAcc(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignBoolToAcc(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignNullToAcc(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignUndefinedToAcc(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignVarToStack(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignRegToStack(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignAccToStack(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignStackToStack(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignConstToStack(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignF32ToStack(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignI32ToStack(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignU32ToStack(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignBoolToStack(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignNullToStack(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::NullishAssignUndefinedToStack(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::DeclConstVar(arg0, arg1) => instruction::decl_const(arg0, arg1, vm)?,
            Self::DeclConstReg(arg0, arg1) => instruction::decl_const(arg0, arg1, vm)?,
            Self::DeclConstAcc(arg0, arg1) => instruction::decl_const(arg0, arg1, vm)?,
            Self::DeclConstStack(arg0, arg1) => instruction::decl_const(arg0, arg1, vm)?,
            Self::DeclConstConst(arg0, arg1) => instruction::decl_const(arg0, arg1, vm)?,
            Self::DeclConstF32(arg0, arg1) => instruction::decl_const(arg0, arg1, vm)?,
            Self::DeclConstI32(arg0, arg1) => instruction::decl_const(arg0, arg1, vm)?,
            Self::DeclConstU32(arg0, arg1) => instruction::decl_const(arg0, arg1, vm)?,
            Self::DeclConstBool(arg0, arg1) => instruction::decl_const(arg0, arg1, vm)?,
            Self::DeclConstNull(arg0, arg1) => instruction::decl_const(arg0, arg1, vm)?,
            Self::DeclConstUndefined(arg0, arg1) => {
                instruction::decl_const(arg0, arg1, vm)?
            }
            Self::DeclVarVar(arg0, arg1) => instruction::decl_var(arg0, arg1, vm)?,
            Self::DeclVarReg(arg0, arg1) => instruction::decl_var(arg0, arg1, vm)?,
            Self::DeclVarAcc(arg0, arg1) => instruction::decl_var(arg0, arg1, vm)?,
            Self::DeclVarStack(arg0, arg1) => instruction::decl_var(arg0, arg1, vm)?,
            Self::DeclVarConst(arg0, arg1) => instruction::decl_var(arg0, arg1, vm)?,
            Self::DeclVarF32(arg0, arg1) => instruction::decl_var(arg0, arg1, vm)?,
            Self::DeclVarI32(arg0, arg1) => instruction::decl_var(arg0, arg1, vm)?,
            Self::DeclVarU32(arg0, arg1) => instruction::decl_var(arg0, arg1, vm)?,
            Self::DeclVarBool(arg0, arg1) => instruction::decl_var(arg0, arg1, vm)?,
            Self::DeclVarNull(arg0, arg1) => instruction::decl_var(arg0, arg1, vm)?,
            Self::DeclVarUndefined(arg0, arg1) => instruction::decl_var(arg0, arg1, vm)?,
            Self::DeclEmptyVar(arg0) => instruction::decl_empty_var(arg0, vm)?,
            Self::DeclLetVar(arg0, arg1) => instruction::decl_let(arg0, arg1, vm)?,
            Self::DeclLetReg(arg0, arg1) => instruction::decl_let(arg0, arg1, vm)?,
            Self::DeclLetAcc(arg0, arg1) => instruction::decl_let(arg0, arg1, vm)?,
            Self::DeclLetStack(arg0, arg1) => instruction::decl_let(arg0, arg1, vm)?,
            Self::DeclLetConst(arg0, arg1) => instruction::decl_let(arg0, arg1, vm)?,
            Self::DeclLetF32(arg0, arg1) => instruction::decl_let(arg0, arg1, vm)?,
            Self::DeclLetI32(arg0, arg1) => instruction::decl_let(arg0, arg1, vm)?,
            Self::DeclLetU32(arg0, arg1) => instruction::decl_let(arg0, arg1, vm)?,
            Self::DeclLetBool(arg0, arg1) => instruction::decl_let(arg0, arg1, vm)?,
            Self::DeclLetNull(arg0, arg1) => instruction::decl_let(arg0, arg1, vm)?,
            Self::DeclLetUndefined(arg0, arg1) => instruction::decl_let(arg0, arg1, vm)?,
            Self::DeclEmptyLet(arg0) => instruction::decl_empty_let(arg0, vm)?,
            Self::PatBeginRest(arg0) => instruction::pat_begin_rest(arg0, vm)?,
            Self::PatVoidNext => instruction::pat_void_next(vm)?,
            Self::PatMoveLetVarVar(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetRegVar(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetAccVar(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetStackVar(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetConstVar(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetF32Var(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetI32Var(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetU32Var(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetBoolVar(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetNullVar(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetUndefinedVar(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetVarReg(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetRegReg(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetAccReg(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetStackReg(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetConstReg(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetF32Reg(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetI32Reg(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetU32Reg(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetBoolReg(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetNullReg(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetUndefinedReg(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetVarAcc(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetRegAcc(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetAccAcc(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetStackAcc(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetConstAcc(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetF32Acc(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetI32Acc(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetU32Acc(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetBoolAcc(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetNullAcc(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetUndefinedAcc(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetVarStack(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetRegStack(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetAccStack(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetStackStack(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetConstStack(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetF32Stack(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetI32Stack(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetU32Stack(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetBoolStack(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetNullStack(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetUndefinedStack(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetVarConst(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetRegConst(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetAccConst(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetStackConst(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetConstConst(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetF32Const(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetI32Const(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetU32Const(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetBoolConst(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetNullConst(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetUndefinedConst(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetVarF32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetRegF32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetAccF32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetStackF32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetConstF32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetF32F32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetI32F32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetU32F32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetBoolF32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetNullF32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetUndefinedF32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetVarI32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetRegI32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetAccI32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetStackI32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetConstI32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetF32I32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetI32I32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetU32I32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetBoolI32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetNullI32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetUndefinedI32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetVarU32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetRegU32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetAccU32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetStackU32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetConstU32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetF32U32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetI32U32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetU32U32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetBoolU32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetNullU32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetUndefinedU32(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetVarBool(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetRegBool(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetAccBool(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetStackBool(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetConstBool(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetF32Bool(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetI32Bool(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetU32Bool(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetBoolBool(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetNullBool(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetUndefinedBool(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetVarNull(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetRegNull(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetAccNull(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetStackNull(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetConstNull(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetF32Null(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetI32Null(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetU32Null(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetBoolNull(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetNullNull(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetUndefinedNull(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetVarUndefined(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetRegUndefined(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetAccUndefined(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetStackUndefined(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetConstUndefined(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetF32Undefined(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetI32Undefined(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetU32Undefined(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetBoolUndefined(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetNullUndefined(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveLetUndefinedUndefined(arg0, arg1) => {
                instruction::pat_move_let(arg0, arg1, vm)?
            }
            Self::PatMoveConstVarVar(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstRegVar(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstAccVar(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstStackVar(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstConstVar(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstF32Var(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstI32Var(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstU32Var(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstBoolVar(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstNullVar(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstUndefinedVar(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstVarReg(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstRegReg(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstAccReg(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstStackReg(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstConstReg(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstF32Reg(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstI32Reg(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstU32Reg(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstBoolReg(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstNullReg(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstUndefinedReg(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstVarAcc(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstRegAcc(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstAccAcc(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstStackAcc(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstConstAcc(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstF32Acc(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstI32Acc(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstU32Acc(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstBoolAcc(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstNullAcc(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstUndefinedAcc(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstVarStack(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstRegStack(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstAccStack(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstStackStack(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstConstStack(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstF32Stack(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstI32Stack(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstU32Stack(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstBoolStack(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstNullStack(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstUndefinedStack(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstVarConst(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstRegConst(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstAccConst(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstStackConst(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstConstConst(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstF32Const(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstI32Const(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstU32Const(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstBoolConst(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstNullConst(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstUndefinedConst(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstVarF32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstRegF32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstAccF32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstStackF32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstConstF32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstF32F32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstI32F32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstU32F32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstBoolF32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstNullF32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstUndefinedF32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstVarI32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstRegI32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstAccI32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstStackI32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstConstI32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstF32I32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstI32I32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstU32I32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstBoolI32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstNullI32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstUndefinedI32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstVarU32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstRegU32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstAccU32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstStackU32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstConstU32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstF32U32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstI32U32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstU32U32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstBoolU32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstNullU32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstUndefinedU32(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstVarBool(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstRegBool(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstAccBool(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstStackBool(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstConstBool(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstF32Bool(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstI32Bool(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstU32Bool(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstBoolBool(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstNullBool(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstUndefinedBool(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstVarNull(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstRegNull(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstAccNull(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstStackNull(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstConstNull(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstF32Null(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstI32Null(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstU32Null(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstBoolNull(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstNullNull(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstUndefinedNull(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstVarUndefined(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstRegUndefined(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstAccUndefined(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstStackUndefined(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstConstUndefined(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstF32Undefined(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstI32Undefined(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstU32Undefined(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstBoolUndefined(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstNullUndefined(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveConstUndefinedUndefined(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveVarVarVar(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarRegVar(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarAccVar(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarStackVar(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarConstVar(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarF32Var(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarI32Var(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarU32Var(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarBoolVar(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarNullVar(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarUndefinedVar(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarVarReg(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarRegReg(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarAccReg(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarStackReg(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarConstReg(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarF32Reg(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarI32Reg(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarU32Reg(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarBoolReg(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarNullReg(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarUndefinedReg(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarVarAcc(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarRegAcc(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarAccAcc(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarStackAcc(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarConstAcc(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarF32Acc(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarI32Acc(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarU32Acc(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarBoolAcc(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarNullAcc(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarUndefinedAcc(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarVarStack(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarRegStack(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarAccStack(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarStackStack(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarConstStack(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarF32Stack(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarI32Stack(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarU32Stack(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarBoolStack(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarNullStack(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarUndefinedStack(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarVarConst(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarRegConst(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarAccConst(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarStackConst(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarConstConst(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarF32Const(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarI32Const(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarU32Const(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarBoolConst(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarNullConst(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarUndefinedConst(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarVarF32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarRegF32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarAccF32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarStackF32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarConstF32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarF32F32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarI32F32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarU32F32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarBoolF32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarNullF32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarUndefinedF32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarVarI32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarRegI32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarAccI32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarStackI32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarConstI32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarF32I32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarI32I32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarU32I32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarBoolI32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarNullI32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarUndefinedI32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarVarU32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarRegU32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarAccU32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarStackU32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarConstU32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarF32U32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarI32U32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarU32U32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarBoolU32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarNullU32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarUndefinedU32(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarVarBool(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarRegBool(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarAccBool(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarStackBool(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarConstBool(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarF32Bool(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarI32Bool(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarU32Bool(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarBoolBool(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarNullBool(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarUndefinedBool(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarVarNull(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarRegNull(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarAccNull(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarStackNull(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarConstNull(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarF32Null(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarI32Null(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarU32Null(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarBoolNull(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarNullNull(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarUndefinedNull(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarVarUndefined(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarRegUndefined(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarAccUndefined(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarStackUndefined(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarConstUndefined(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarF32Undefined(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarI32Undefined(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarU32Undefined(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarBoolUndefined(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarNullUndefined(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatMoveVarUndefinedUndefined(arg0, arg1) => {
                instruction::pat_move_var(arg0, arg1, vm)?
            }
            Self::PatRestLetVar(arg0) => instruction::pat_rest_let(arg0, vm)?,
            Self::PatRestLetReg(arg0) => instruction::pat_rest_let(arg0, vm)?,
            Self::PatRestLetAcc(arg0) => instruction::pat_rest_let(arg0, vm)?,
            Self::PatRestLetStack(arg0) => instruction::pat_rest_let(arg0, vm)?,
            Self::PatRestLetConst(arg0) => instruction::pat_rest_let(arg0, vm)?,
            Self::PatRestLetF32(arg0) => instruction::pat_rest_let(arg0, vm)?,
            Self::PatRestLetI32(arg0) => instruction::pat_rest_let(arg0, vm)?,
            Self::PatRestLetU32(arg0) => instruction::pat_rest_let(arg0, vm)?,
            Self::PatRestLetBool(arg0) => instruction::pat_rest_let(arg0, vm)?,
            Self::PatRestLetNull(arg0) => instruction::pat_rest_let(arg0, vm)?,
            Self::PatRestLetUndefined(arg0) => instruction::pat_rest_let(arg0, vm)?,
            Self::PatRestConstVar(arg0) => instruction::pat_rest_const(arg0, vm)?,
            Self::PatRestConstReg(arg0) => instruction::pat_rest_const(arg0, vm)?,
            Self::PatRestConstAcc(arg0) => instruction::pat_rest_const(arg0, vm)?,
            Self::PatRestConstStack(arg0) => instruction::pat_rest_const(arg0, vm)?,
            Self::PatRestConstConst(arg0) => instruction::pat_rest_const(arg0, vm)?,
            Self::PatRestConstF32(arg0) => instruction::pat_rest_const(arg0, vm)?,
            Self::PatRestConstI32(arg0) => instruction::pat_rest_const(arg0, vm)?,
            Self::PatRestConstU32(arg0) => instruction::pat_rest_const(arg0, vm)?,
            Self::PatRestConstBool(arg0) => instruction::pat_rest_const(arg0, vm)?,
            Self::PatRestConstNull(arg0) => instruction::pat_rest_const(arg0, vm)?,
            Self::PatRestConstUndefined(arg0) => instruction::pat_rest_const(arg0, vm)?,
            Self::PatRestVarVar(arg0) => instruction::pat_rest_var(arg0, vm)?,
            Self::PatRestVarReg(arg0) => instruction::pat_rest_var(arg0, vm)?,
            Self::PatRestVarAcc(arg0) => instruction::pat_rest_var(arg0, vm)?,
            Self::PatRestVarStack(arg0) => instruction::pat_rest_var(arg0, vm)?,
            Self::PatRestVarConst(arg0) => instruction::pat_rest_var(arg0, vm)?,
            Self::PatRestVarF32(arg0) => instruction::pat_rest_var(arg0, vm)?,
            Self::PatRestVarI32(arg0) => instruction::pat_rest_var(arg0, vm)?,
            Self::PatRestVarU32(arg0) => instruction::pat_rest_var(arg0, vm)?,
            Self::PatRestVarBool(arg0) => instruction::pat_rest_var(arg0, vm)?,
            Self::PatRestVarNull(arg0) => instruction::pat_rest_var(arg0, vm)?,
            Self::PatRestVarUndefined(arg0) => instruction::pat_rest_var(arg0, vm)?,
            Self::PatArrayMoveLetVar(arg0) => instruction::pat_array_move_let(arg0, vm)?,
            Self::PatArrayMoveLetReg(arg0) => instruction::pat_array_move_let(arg0, vm)?,
            Self::PatArrayMoveLetAcc(arg0) => instruction::pat_array_move_let(arg0, vm)?,
            Self::PatArrayMoveLetStack(arg0) => {
                instruction::pat_array_move_let(arg0, vm)?
            }
            Self::PatArrayMoveLetConst(arg0) => {
                instruction::pat_array_move_let(arg0, vm)?
            }
            Self::PatArrayMoveLetF32(arg0) => instruction::pat_array_move_let(arg0, vm)?,
            Self::PatArrayMoveLetI32(arg0) => instruction::pat_array_move_let(arg0, vm)?,
            Self::PatArrayMoveLetU32(arg0) => instruction::pat_array_move_let(arg0, vm)?,
            Self::PatArrayMoveLetBool(arg0) => instruction::pat_array_move_let(arg0, vm)?,
            Self::PatArrayMoveLetNull(arg0) => instruction::pat_array_move_let(arg0, vm)?,
            Self::PatArrayMoveLetUndefined(arg0) => {
                instruction::pat_array_move_let(arg0, vm)?
            }
            Self::PatArrayMoveConstVar(arg0) => {
                instruction::pat_array_move_const(arg0, vm)?
            }
            Self::PatArrayMoveConstReg(arg0) => {
                instruction::pat_array_move_const(arg0, vm)?
            }
            Self::PatArrayMoveConstAcc(arg0) => {
                instruction::pat_array_move_const(arg0, vm)?
            }
            Self::PatArrayMoveConstStack(arg0) => {
                instruction::pat_array_move_const(arg0, vm)?
            }
            Self::PatArrayMoveConstConst(arg0) => {
                instruction::pat_array_move_const(arg0, vm)?
            }
            Self::PatArrayMoveConstF32(arg0) => {
                instruction::pat_array_move_const(arg0, vm)?
            }
            Self::PatArrayMoveConstI32(arg0) => {
                instruction::pat_array_move_const(arg0, vm)?
            }
            Self::PatArrayMoveConstU32(arg0) => {
                instruction::pat_array_move_const(arg0, vm)?
            }
            Self::PatArrayMoveConstBool(arg0) => {
                instruction::pat_array_move_const(arg0, vm)?
            }
            Self::PatArrayMoveConstNull(arg0) => {
                instruction::pat_array_move_const(arg0, vm)?
            }
            Self::PatArrayMoveConstUndefined(arg0) => {
                instruction::pat_array_move_const(arg0, vm)?
            }
            Self::PatArrayMoveVarVar(arg0) => instruction::pat_array_move_var(arg0, vm)?,
            Self::PatArrayMoveVarReg(arg0) => instruction::pat_array_move_var(arg0, vm)?,
            Self::PatArrayMoveVarAcc(arg0) => instruction::pat_array_move_var(arg0, vm)?,
            Self::PatArrayMoveVarStack(arg0) => {
                instruction::pat_array_move_var(arg0, vm)?
            }
            Self::PatArrayMoveVarConst(arg0) => {
                instruction::pat_array_move_var(arg0, vm)?
            }
            Self::PatArrayMoveVarF32(arg0) => instruction::pat_array_move_var(arg0, vm)?,
            Self::PatArrayMoveVarI32(arg0) => instruction::pat_array_move_var(arg0, vm)?,
            Self::PatArrayMoveVarU32(arg0) => instruction::pat_array_move_var(arg0, vm)?,
            Self::PatArrayMoveVarBool(arg0) => instruction::pat_array_move_var(arg0, vm)?,
            Self::PatArrayMoveVarNull(arg0) => instruction::pat_array_move_var(arg0, vm)?,
            Self::PatArrayMoveVarUndefined(arg0) => {
                instruction::pat_array_move_var(arg0, vm)?
            }
            Self::PatArrayRestLetVar(arg0) => instruction::pat_array_rest_let(arg0, vm)?,
            Self::PatArrayRestLetReg(arg0) => instruction::pat_array_rest_let(arg0, vm)?,
            Self::PatArrayRestLetAcc(arg0) => instruction::pat_array_rest_let(arg0, vm)?,
            Self::PatArrayRestLetStack(arg0) => {
                instruction::pat_array_rest_let(arg0, vm)?
            }
            Self::PatArrayRestLetConst(arg0) => {
                instruction::pat_array_rest_let(arg0, vm)?
            }
            Self::PatArrayRestLetF32(arg0) => instruction::pat_array_rest_let(arg0, vm)?,
            Self::PatArrayRestLetI32(arg0) => instruction::pat_array_rest_let(arg0, vm)?,
            Self::PatArrayRestLetU32(arg0) => instruction::pat_array_rest_let(arg0, vm)?,
            Self::PatArrayRestLetBool(arg0) => instruction::pat_array_rest_let(arg0, vm)?,
            Self::PatArrayRestLetNull(arg0) => instruction::pat_array_rest_let(arg0, vm)?,
            Self::PatArrayRestLetUndefined(arg0) => {
                instruction::pat_array_rest_let(arg0, vm)?
            }
            Self::PatArrayRestConstVar(arg0) => {
                instruction::pat_array_rest_const(arg0, vm)?
            }
            Self::PatArrayRestConstReg(arg0) => {
                instruction::pat_array_rest_const(arg0, vm)?
            }
            Self::PatArrayRestConstAcc(arg0) => {
                instruction::pat_array_rest_const(arg0, vm)?
            }
            Self::PatArrayRestConstStack(arg0) => {
                instruction::pat_array_rest_const(arg0, vm)?
            }
            Self::PatArrayRestConstConst(arg0) => {
                instruction::pat_array_rest_const(arg0, vm)?
            }
            Self::PatArrayRestConstF32(arg0) => {
                instruction::pat_array_rest_const(arg0, vm)?
            }
            Self::PatArrayRestConstI32(arg0) => {
                instruction::pat_array_rest_const(arg0, vm)?
            }
            Self::PatArrayRestConstU32(arg0) => {
                instruction::pat_array_rest_const(arg0, vm)?
            }
            Self::PatArrayRestConstBool(arg0) => {
                instruction::pat_array_rest_const(arg0, vm)?
            }
            Self::PatArrayRestConstNull(arg0) => {
                instruction::pat_array_rest_const(arg0, vm)?
            }
            Self::PatArrayRestConstUndefined(arg0) => {
                instruction::pat_array_rest_const(arg0, vm)?
            }
            Self::PatArrayRestVarVar(arg0) => instruction::pat_array_rest_var(arg0, vm)?,
            Self::PatArrayRestVarReg(arg0) => instruction::pat_array_rest_var(arg0, vm)?,
            Self::PatArrayRestVarAcc(arg0) => instruction::pat_array_rest_var(arg0, vm)?,
            Self::PatArrayRestVarStack(arg0) => {
                instruction::pat_array_rest_var(arg0, vm)?
            }
            Self::PatArrayRestVarConst(arg0) => {
                instruction::pat_array_rest_var(arg0, vm)?
            }
            Self::PatArrayRestVarF32(arg0) => instruction::pat_array_rest_var(arg0, vm)?,
            Self::PatArrayRestVarI32(arg0) => instruction::pat_array_rest_var(arg0, vm)?,
            Self::PatArrayRestVarU32(arg0) => instruction::pat_array_rest_var(arg0, vm)?,
            Self::PatArrayRestVarBool(arg0) => instruction::pat_array_rest_var(arg0, vm)?,
            Self::PatArrayRestVarNull(arg0) => instruction::pat_array_rest_var(arg0, vm)?,
            Self::PatArrayRestVarUndefined(arg0) => {
                instruction::pat_array_rest_var(arg0, vm)?
            }
            Self::PushIterVarToVar(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterRegToVar(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterAccToVar(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterStackToVar(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterConstToVar(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterF32ToVar(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterI32ToVar(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterU32ToVar(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterBoolToVar(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterNullToVar(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterUndefinedToVar(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterVarToReg(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterRegToReg(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterAccToReg(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterStackToReg(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterConstToReg(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterF32ToReg(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterI32ToReg(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterU32ToReg(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterBoolToReg(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterNullToReg(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterUndefinedToReg(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterVarToAcc(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterRegToAcc(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterAccToAcc(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterStackToAcc(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterConstToAcc(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterF32ToAcc(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterI32ToAcc(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterU32ToAcc(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterBoolToAcc(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterNullToAcc(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterUndefinedToAcc(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterVarToStack(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterRegToStack(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterAccToStack(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterStackToStack(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterConstToStack(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterF32ToStack(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterI32ToStack(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterU32ToStack(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterBoolToStack(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterNullToStack(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::PushIterUndefinedToStack(arg0, output) => {
                instruction::push_iter(arg0, output, vm)?
            }
            Self::IterNextVarToVar(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextRegToVar(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextAccToVar(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextStackToVar(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextConstToVar(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextF32ToVar(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextI32ToVar(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextU32ToVar(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextBoolToVar(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextNullToVar(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextUndefinedToVar(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextVarToReg(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextRegToReg(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextAccToReg(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextStackToReg(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextConstToReg(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextF32ToReg(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextI32ToReg(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextU32ToReg(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextBoolToReg(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextNullToReg(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextUndefinedToReg(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextVarToAcc(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextRegToAcc(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextAccToAcc(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextStackToAcc(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextConstToAcc(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextF32ToAcc(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextI32ToAcc(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextU32ToAcc(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextBoolToAcc(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextNullToAcc(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextUndefinedToAcc(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextVarToStack(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextRegToStack(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextAccToStack(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextStackToStack(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextConstToStack(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextF32ToStack(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextI32ToStack(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextU32ToStack(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextBoolToStack(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextNullToStack(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextUndefinedToStack(arg0, output) => {
                instruction::iter_next(arg0, output, vm)?
            }
            Self::IterNextNoOutputVar(arg0) => {
                instruction::iter_next_no_output(arg0, vm)?
            }
            Self::IterNextNoOutputReg(arg0) => {
                instruction::iter_next_no_output(arg0, vm)?
            }
            Self::IterNextNoOutputAcc(arg0) => {
                instruction::iter_next_no_output(arg0, vm)?
            }
            Self::IterNextNoOutputStack(arg0) => {
                instruction::iter_next_no_output(arg0, vm)?
            }
            Self::IterNextNoOutputConst(arg0) => {
                instruction::iter_next_no_output(arg0, vm)?
            }
            Self::IterNextNoOutputF32(arg0) => {
                instruction::iter_next_no_output(arg0, vm)?
            }
            Self::IterNextNoOutputI32(arg0) => {
                instruction::iter_next_no_output(arg0, vm)?
            }
            Self::IterNextNoOutputU32(arg0) => {
                instruction::iter_next_no_output(arg0, vm)?
            }
            Self::IterNextNoOutputBool(arg0) => {
                instruction::iter_next_no_output(arg0, vm)?
            }
            Self::IterNextNoOutputNull(arg0) => {
                instruction::iter_next_no_output(arg0, vm)?
            }
            Self::IterNextNoOutputUndefined(arg0) => {
                instruction::iter_next_no_output(arg0, vm)?
            }
            Self::IterNextJmpVarToVar(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpRegToVar(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpAccToVar(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpStackToVar(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpConstToVar(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpF32ToVar(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpI32ToVar(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpU32ToVar(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpBoolToVar(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpNullToVar(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpUndefinedToVar(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpVarToReg(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpRegToReg(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpAccToReg(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpStackToReg(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpConstToReg(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpF32ToReg(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpI32ToReg(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpU32ToReg(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpBoolToReg(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpNullToReg(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpUndefinedToReg(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpVarToAcc(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpRegToAcc(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpAccToAcc(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpStackToAcc(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpConstToAcc(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpF32ToAcc(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpI32ToAcc(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpU32ToAcc(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpBoolToAcc(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpNullToAcc(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpUndefinedToAcc(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpVarToStack(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpRegToStack(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpAccToStack(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpStackToStack(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpConstToStack(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpF32ToStack(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpI32ToStack(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpU32ToStack(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpBoolToStack(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpNullToStack(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextJmpUndefinedToStack(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextNoOutputJmpVar(arg0, arg1) => {
                instruction::iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::IterNextNoOutputJmpReg(arg0, arg1) => {
                instruction::iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::IterNextNoOutputJmpAcc(arg0, arg1) => {
                instruction::iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::IterNextNoOutputJmpStack(arg0, arg1) => {
                instruction::iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::IterNextNoOutputJmpConst(arg0, arg1) => {
                instruction::iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::IterNextNoOutputJmpF32(arg0, arg1) => {
                instruction::iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::IterNextNoOutputJmpI32(arg0, arg1) => {
                instruction::iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::IterNextNoOutputJmpU32(arg0, arg1) => {
                instruction::iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::IterNextNoOutputJmpBool(arg0, arg1) => {
                instruction::iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::IterNextNoOutputJmpNull(arg0, arg1) => {
                instruction::iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::IterNextNoOutputJmpUndefined(arg0, arg1) => {
                instruction::iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::IterCollectVarToVar(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectRegToVar(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectAccToVar(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectStackToVar(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectConstToVar(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectF32ToVar(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectI32ToVar(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectU32ToVar(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectBoolToVar(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectNullToVar(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectUndefinedToVar(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectVarToReg(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectRegToReg(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectAccToReg(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectStackToReg(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectConstToReg(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectF32ToReg(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectI32ToReg(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectU32ToReg(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectBoolToReg(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectNullToReg(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectUndefinedToReg(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectVarToAcc(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectRegToAcc(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectAccToAcc(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectStackToAcc(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectConstToAcc(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectF32ToAcc(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectI32ToAcc(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectU32ToAcc(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectBoolToAcc(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectNullToAcc(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectUndefinedToAcc(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectVarToStack(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectRegToStack(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectAccToStack(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectStackToStack(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectConstToStack(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectF32ToStack(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectI32ToStack(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectU32ToStack(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectBoolToStack(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectNullToStack(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::IterCollectUndefinedToStack(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::PushAsyncIterVarToVar(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterRegToVar(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterAccToVar(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterStackToVar(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterConstToVar(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterF32ToVar(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterI32ToVar(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterU32ToVar(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterBoolToVar(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterNullToVar(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterUndefinedToVar(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterVarToReg(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterRegToReg(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterAccToReg(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterStackToReg(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterConstToReg(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterF32ToReg(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterI32ToReg(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterU32ToReg(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterBoolToReg(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterNullToReg(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterUndefinedToReg(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterVarToAcc(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterRegToAcc(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterAccToAcc(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterStackToAcc(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterConstToAcc(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterF32ToAcc(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterI32ToAcc(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterU32ToAcc(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterBoolToAcc(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterNullToAcc(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterUndefinedToAcc(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterVarToStack(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterRegToStack(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterAccToStack(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterStackToStack(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterConstToStack(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterF32ToStack(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterI32ToStack(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterU32ToStack(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterBoolToStack(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterNullToStack(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::PushAsyncIterUndefinedToStack(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::AsyncIterPollNextVarToVar(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextRegToVar(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextAccToVar(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextStackToVar(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextConstToVar(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextF32ToVar(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextI32ToVar(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextU32ToVar(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextBoolToVar(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextNullToVar(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextUndefinedToVar(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextVarToReg(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextRegToReg(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextAccToReg(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextStackToReg(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextConstToReg(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextF32ToReg(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextI32ToReg(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextU32ToReg(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextBoolToReg(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextNullToReg(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextUndefinedToReg(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextVarToAcc(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextRegToAcc(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextAccToAcc(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextStackToAcc(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextConstToAcc(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextF32ToAcc(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextI32ToAcc(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextU32ToAcc(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextBoolToAcc(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextNullToAcc(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextUndefinedToAcc(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextVarToStack(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextRegToStack(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextAccToStack(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextStackToStack(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextConstToStack(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextF32ToStack(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextI32ToStack(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextU32ToStack(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextBoolToStack(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextNullToStack(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterPollNextUndefinedToStack(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterNextVarToVar(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextRegToVar(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextAccToVar(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextStackToVar(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextConstToVar(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextF32ToVar(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextI32ToVar(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextU32ToVar(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextBoolToVar(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextNullToVar(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextUndefinedToVar(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextVarToReg(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextRegToReg(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextAccToReg(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextStackToReg(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextConstToReg(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextF32ToReg(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextI32ToReg(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextU32ToReg(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextBoolToReg(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextNullToReg(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextUndefinedToReg(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextVarToAcc(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextRegToAcc(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextAccToAcc(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextStackToAcc(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextConstToAcc(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextF32ToAcc(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextI32ToAcc(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextU32ToAcc(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextBoolToAcc(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextNullToAcc(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextUndefinedToAcc(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextVarToStack(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextRegToStack(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextAccToStack(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextStackToStack(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextConstToStack(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextF32ToStack(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextI32ToStack(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextU32ToStack(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextBoolToStack(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextNullToStack(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextUndefinedToStack(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextJmpVarToVar(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpRegToVar(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpAccToVar(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpStackToVar(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpConstToVar(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpF32ToVar(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpI32ToVar(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpU32ToVar(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpBoolToVar(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpNullToVar(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpUndefinedToVar(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpVarToReg(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpRegToReg(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpAccToReg(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpStackToReg(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpConstToReg(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpF32ToReg(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpI32ToReg(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpU32ToReg(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpBoolToReg(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpNullToReg(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpUndefinedToReg(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpVarToAcc(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpRegToAcc(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpAccToAcc(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpStackToAcc(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpConstToAcc(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpF32ToAcc(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpI32ToAcc(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpU32ToAcc(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpBoolToAcc(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpNullToAcc(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpUndefinedToAcc(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpVarToStack(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpRegToStack(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpAccToStack(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpStackToStack(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpConstToStack(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpF32ToStack(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpI32ToStack(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpU32ToStack(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpBoolToStack(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpNullToStack(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextJmpUndefinedToStack(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextNoOutputJmpVar(arg0, arg1) => {
                instruction::async_iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::AsyncIterNextNoOutputJmpReg(arg0, arg1) => {
                instruction::async_iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::AsyncIterNextNoOutputJmpAcc(arg0, arg1) => {
                instruction::async_iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::AsyncIterNextNoOutputJmpStack(arg0, arg1) => {
                instruction::async_iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::AsyncIterNextNoOutputJmpConst(arg0, arg1) => {
                instruction::async_iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::AsyncIterNextNoOutputJmpF32(arg0, arg1) => {
                instruction::async_iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::AsyncIterNextNoOutputJmpI32(arg0, arg1) => {
                instruction::async_iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::AsyncIterNextNoOutputJmpU32(arg0, arg1) => {
                instruction::async_iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::AsyncIterNextNoOutputJmpBool(arg0, arg1) => {
                instruction::async_iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::AsyncIterNextNoOutputJmpNull(arg0, arg1) => {
                instruction::async_iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::AsyncIterNextNoOutputJmpUndefined(arg0, arg1) => {
                instruction::async_iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::ThrowIfNotObjectVar(arg0) => {
                instruction::throw_if_not_object(arg0, vm)?
            }
            Self::ThrowIfNotObjectReg(arg0) => {
                instruction::throw_if_not_object(arg0, vm)?
            }
            Self::ThrowIfNotObjectAcc(arg0) => {
                instruction::throw_if_not_object(arg0, vm)?
            }
            Self::ThrowIfNotObjectStack(arg0) => {
                instruction::throw_if_not_object(arg0, vm)?
            }
            Self::ThrowIfNotObjectConst(arg0) => {
                instruction::throw_if_not_object(arg0, vm)?
            }
            Self::ThrowIfNotObjectF32(arg0) => {
                instruction::throw_if_not_object(arg0, vm)?
            }
            Self::ThrowIfNotObjectI32(arg0) => {
                instruction::throw_if_not_object(arg0, vm)?
            }
            Self::ThrowIfNotObjectU32(arg0) => {
                instruction::throw_if_not_object(arg0, vm)?
            }
            Self::ThrowIfNotObjectBool(arg0) => {
                instruction::throw_if_not_object(arg0, vm)?
            }
            Self::ThrowIfNotObjectNull(arg0) => {
                instruction::throw_if_not_object(arg0, vm)?
            }
            Self::ThrowIfNotObjectUndefined(arg0) => {
                instruction::throw_if_not_object(arg0, vm)?
            }
        }
        Ok(())
    }
}
#[cfg(feature = "simple_bytecode")]
impl Execute for Instruction {
    fn execute(self, vm: &mut impl VM) -> ControlResult {
        match self {
            Self::Add(arg0, arg1, output) => instruction::add(arg0, arg1, output, vm)?,
            Self::Sub(arg0, arg1, output) => instruction::sub(arg0, arg1, output, vm)?,
            Self::Mul(arg0, arg1, output) => instruction::mul(arg0, arg1, output, vm)?,
            Self::Div(arg0, arg1, output) => instruction::div(arg0, arg1, output, vm)?,
            Self::Mod(arg0, arg1, output) => instruction::mod_(arg0, arg1, output, vm)?,
            Self::LNot(arg0, output) => instruction::l_not(arg0, output, vm)?,
            Self::LOr(arg0, arg1, output) => instruction::l_or(arg0, arg1, output, vm)?,
            Self::LAnd(arg0, arg1, output) => instruction::l_and(arg0, arg1, output, vm)?,
            Self::BXor(arg0, arg1, output) => instruction::b_xor(arg0, arg1, output, vm)?,
            Self::BOr(arg0, arg1, output) => instruction::b_or(arg0, arg1, output, vm)?,
            Self::BAnd(arg0, arg1, output) => instruction::b_and(arg0, arg1, output, vm)?,
            Self::Eq(arg0, arg1, output) => instruction::eq(arg0, arg1, output, vm)?,
            Self::Ne(arg0, arg1, output) => instruction::ne(arg0, arg1, output, vm)?,
            Self::StrictEq(arg0, arg1, output) => {
                instruction::strict_eq(arg0, arg1, output, vm)?
            }
            Self::StrictNe(arg0, arg1, output) => {
                instruction::strict_ne(arg0, arg1, output, vm)?
            }
            Self::Lt(arg0, arg1, output) => instruction::lt(arg0, arg1, output, vm)?,
            Self::LtEq(arg0, arg1, output) => instruction::lt_eq(arg0, arg1, output, vm)?,
            Self::Gt(arg0, arg1, output) => instruction::gt(arg0, arg1, output, vm)?,
            Self::GtEq(arg0, arg1, output) => instruction::gt_eq(arg0, arg1, output, vm)?,
            Self::LShift(arg0, arg1, output) => {
                instruction::l_shift(arg0, arg1, output, vm)?
            }
            Self::RShift(arg0, arg1, output) => {
                instruction::r_shift(arg0, arg1, output, vm)?
            }
            Self::ZeroFillRShift(arg0, arg1, output) => {
                instruction::zero_fill_r_shift(arg0, arg1, output, vm)?
            }
            Self::In(arg0, arg1, output) => instruction::in_(arg0, arg1, output, vm)?,
            Self::InstanceOf(arg0, arg1, output) => {
                instruction::instance_of(arg0, arg1, output, vm)?
            }
            Self::Exp(arg0, arg1, output) => instruction::exp(arg0, arg1, output, vm)?,
            Self::NullishCoalescing(arg0, arg1, output) => {
                instruction::nullish_coalescing(arg0, arg1, output, vm)?
            }
            Self::Dec(arg0, output) => instruction::dec(arg0, output, vm)?,
            Self::Inc(arg0, output) => instruction::inc(arg0, output, vm)?,
            Self::PushScope => instruction::push_scope(vm)?,
            Self::PushLoopScope => instruction::push_loop_scope(vm)?,
            Self::PopScope => instruction::pop_scope(vm)?,
            Self::Call(arg0, output) => instruction::call(arg0, output, vm)?,
            Self::CallNoOutput(arg0) => instruction::call_no_output(arg0, vm)?,
            Self::CallMember(arg0, arg1, output) => {
                instruction::call_member(arg0, arg1, output, vm)?
            }
            Self::CallMemberNoOutput(arg0, arg1) => {
                instruction::call_member_no_output(arg0, arg1, vm)?
            }
            Self::CallSuper(output) => instruction::call_super(output, vm)?,
            Self::CallSuperNoOutput => instruction::call_super_no_output(vm)?,
            Self::Construct(arg0, output) => instruction::construct(arg0, output, vm)?,
            Self::ConstructNoOutput(arg0) => instruction::construct_no_output(arg0, vm)?,
            Self::PushCall(arg0) => instruction::push_call(arg0, vm)?,
            Self::SpreadCall(arg0) => instruction::spread_call(arg0, vm)?,
            Self::Jmp(arg0) => instruction::jmp(arg0, vm)?,
            Self::JmpIf(arg0, arg1) => instruction::jmp_if(arg0, arg1, vm)?,
            Self::JmpIfNot(arg0, arg1) => instruction::jmp_if_not(arg0, arg1, vm)?,
            Self::JmpIfNull(arg0, arg1) => instruction::jmp_if_null(arg0, arg1, vm)?,
            Self::JmpIfNotNull(arg0, arg1) => {
                instruction::jmp_if_not_null(arg0, arg1, vm)?
            }
            Self::JmpIfUndefined(arg0, arg1) => {
                instruction::jmp_if_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefined(arg0, arg1) => {
                instruction::jmp_if_not_undefined(arg0, arg1, vm)?
            }
            Self::JmpIfNullish(arg0, arg1) => {
                instruction::jmp_if_nullish(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullish(arg0, arg1) => {
                instruction::jmp_if_not_nullish(arg0, arg1, vm)?
            }
            Self::JmpRel(arg0) => instruction::jmp_rel(arg0, vm)?,
            Self::JmpIfRel(arg0, arg1) => instruction::jmp_if_rel(arg0, arg1, vm)?,
            Self::JmpIfNotRel(arg0, arg1) => instruction::jmp_if_not_rel(arg0, arg1, vm)?,
            Self::JmpIfNullRel(arg0, arg1) => {
                instruction::jmp_if_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullRel(arg0, arg1) => {
                instruction::jmp_if_not_null_rel(arg0, arg1, vm)?
            }
            Self::JmpIfUndefinedRel(arg0, arg1) => {
                instruction::jmp_if_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotUndefinedRel(arg0, arg1) => {
                instruction::jmp_if_not_undefined_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNullishRel(arg0, arg1) => {
                instruction::jmp_if_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfNotNullishRel(arg0, arg1) => {
                instruction::jmp_if_not_nullish_rel(arg0, arg1, vm)?
            }
            Self::JmpIfEq(arg0, arg1, arg2) => {
                instruction::jmp_if_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNe(arg0, arg1, arg2) => {
                instruction::jmp_if_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEq(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNe(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLt(arg0, arg1, arg2) => {
                instruction::jmp_if_lt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEq(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGt(arg0, arg1, arg2) => {
                instruction::jmp_if_gt(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEq(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfEqRel(arg0, arg1, arg2) => {
                instruction::jmp_if_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfNeRel(arg0, arg1, arg2) => {
                instruction::jmp_if_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictEqRel(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfStrictNeRel(arg0, arg1, arg2) => {
                instruction::jmp_if_strict_ne_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtRel(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfLtEqRel(arg0, arg1, arg2) => {
                instruction::jmp_if_lt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtRel(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_rel(arg0, arg1, arg2, vm)?
            }
            Self::JmpIfGtEqRel(arg0, arg1, arg2) => {
                instruction::jmp_if_gt_eq_rel(arg0, arg1, arg2, vm)?
            }
            Self::LoadMember(arg0, arg1, output) => {
                instruction::load_member(arg0, arg1, output, vm)?
            }
            Self::LoadVar(arg0, output) => instruction::load_var(arg0, output, vm)?,
            Self::TypeOf(arg0, output) => instruction::type_of(arg0, output, vm)?,
            Self::Push(arg0) => instruction::push(arg0, vm)?,
            Self::Pop => instruction::pop(vm)?,
            Self::PopN(arg0) => instruction::pop_n(arg0, vm)?,
            Self::PopTo(output) => instruction::pop_to(output, vm)?,
            Self::Move(arg0, output) => instruction::move_(arg0, output, vm)?,
            Self::Return => instruction::return_(vm)?,
            Self::ReturnValue(arg0) => instruction::return_value(arg0, vm)?,
            Self::Break => instruction::break_(vm)?,
            Self::BreakLabel(arg0) => instruction::break_label(arg0, vm)?,
            Self::Continue => instruction::continue_(vm)?,
            Self::ContinueLabel(arg0) => instruction::continue_label(arg0, vm)?,
            Self::Throw(arg0) => instruction::throw(arg0, vm)?,
            Self::This(output) => instruction::this(output, vm)?,
            Self::LoadSuper(output) => instruction::load_super(output, vm)?,
            Self::LoadSuperConstructor(output) => {
                instruction::load_super_constructor(output, vm)?
            }
            Self::Yield(arg0) => instruction::yield_(arg0, vm)?,
            Self::YieldUndefined => instruction::yield_undefined(vm)?,
            Self::Await(arg0, output) => instruction::await_(arg0, output, vm)?,
            Self::AwaitNoOutput(arg0) => instruction::await_no_output(arg0, vm)?,
            Self::Debugger => instruction::debugger(vm)?,
            Self::With(arg0) => instruction::with(arg0, vm)?,
            Self::EnterTry(arg0) => instruction::enter_try(arg0, vm)?,
            Self::LeaveTry => instruction::leave_try(vm)?,
            Self::AddAssign(arg0, output) => instruction::add_assign(arg0, output, vm)?,
            Self::SubAssign(arg0, output) => instruction::sub_assign(arg0, output, vm)?,
            Self::MulAssign(arg0, output) => instruction::mul_assign(arg0, output, vm)?,
            Self::DivAssign(arg0, output) => instruction::div_assign(arg0, output, vm)?,
            Self::RemAssign(arg0, output) => instruction::rem_assign(arg0, output, vm)?,
            Self::LShiftAssign(arg0, output) => {
                instruction::l_shift_assign(arg0, output, vm)?
            }
            Self::RShiftAssign(arg0, output) => {
                instruction::r_shift_assign(arg0, output, vm)?
            }
            Self::ZeroFillRShiftAssign(arg0, output) => {
                instruction::zero_fill_r_shift_assign(arg0, output, vm)?
            }
            Self::BAndAssign(arg0, output) => {
                instruction::b_and_assign(arg0, output, vm)?
            }
            Self::BOrAssign(arg0, output) => instruction::b_or_assign(arg0, output, vm)?,
            Self::BXorAssign(arg0, output) => {
                instruction::b_xor_assign(arg0, output, vm)?
            }
            Self::ExpAssign(arg0, output) => instruction::exp_assign(arg0, output, vm)?,
            Self::AndAssign(arg0, output) => instruction::and_assign(arg0, output, vm)?,
            Self::OrAssign(arg0, output) => instruction::or_assign(arg0, output, vm)?,
            Self::NullishAssign(arg0, output) => {
                instruction::nullish_assign(arg0, output, vm)?
            }
            Self::DeclConst(arg0, arg1) => instruction::decl_const(arg0, arg1, vm)?,
            Self::DeclVar(arg0, arg1) => instruction::decl_var(arg0, arg1, vm)?,
            Self::DeclEmptyVar(arg0) => instruction::decl_empty_var(arg0, vm)?,
            Self::DeclLet(arg0, arg1) => instruction::decl_let(arg0, arg1, vm)?,
            Self::DeclEmptyLet(arg0) => instruction::decl_empty_let(arg0, vm)?,
            Self::PatBeginRest(arg0) => instruction::pat_begin_rest(arg0, vm)?,
            Self::PatVoidNext => instruction::pat_void_next(vm)?,
            Self::PatMoveLet(arg0, arg1) => instruction::pat_move_let(arg0, arg1, vm)?,
            Self::PatMoveConst(arg0, arg1) => {
                instruction::pat_move_const(arg0, arg1, vm)?
            }
            Self::PatMoveVar(arg0, arg1) => instruction::pat_move_var(arg0, arg1, vm)?,
            Self::PatRestLet(arg0) => instruction::pat_rest_let(arg0, vm)?,
            Self::PatRestConst(arg0) => instruction::pat_rest_const(arg0, vm)?,
            Self::PatRestVar(arg0) => instruction::pat_rest_var(arg0, vm)?,
            Self::PatArrayMoveLet(arg0) => instruction::pat_array_move_let(arg0, vm)?,
            Self::PatArrayMoveConst(arg0) => instruction::pat_array_move_const(arg0, vm)?,
            Self::PatArrayMoveVar(arg0) => instruction::pat_array_move_var(arg0, vm)?,
            Self::PatArrayRestLet(arg0) => instruction::pat_array_rest_let(arg0, vm)?,
            Self::PatArrayRestConst(arg0) => instruction::pat_array_rest_const(arg0, vm)?,
            Self::PatArrayRestVar(arg0) => instruction::pat_array_rest_var(arg0, vm)?,
            Self::PushIter(arg0, output) => instruction::push_iter(arg0, output, vm)?,
            Self::IterNext(arg0, output) => instruction::iter_next(arg0, output, vm)?,
            Self::IterNextNoOutput(arg0) => instruction::iter_next_no_output(arg0, vm)?,
            Self::IterNextJmp(arg0, arg1, output) => {
                instruction::iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::IterNextNoOutputJmp(arg0, arg1) => {
                instruction::iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::IterCollect(arg0, output) => {
                instruction::iter_collect(arg0, output, vm)?
            }
            Self::PushAsyncIter(arg0, output) => {
                instruction::push_async_iter(arg0, output, vm)?
            }
            Self::AsyncIterPollNext(arg0, output) => {
                instruction::async_iter_poll_next(arg0, output, vm)?
            }
            Self::AsyncIterNext(arg0, output) => {
                instruction::async_iter_next(arg0, output, vm)?
            }
            Self::AsyncIterNextJmp(arg0, arg1, output) => {
                instruction::async_iter_next_jmp(arg0, arg1, output, vm)?
            }
            Self::AsyncIterNextNoOutputJmp(arg0, arg1) => {
                instruction::async_iter_next_no_output_jmp(arg0, arg1, vm)?
            }
            Self::ThrowIfNotObject(arg0) => instruction::throw_if_not_object(arg0, vm)?,
        }
        Ok(())
    }
}
