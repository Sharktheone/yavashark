use crate::span::Span;

pub struct Keyword {
    pub keyword: KeywordType,
    pub span: Span,
}

enum KeywordType {
    Break,
    Case,
    Catch,
    Class,
    Const,
    Continue,
    Debugger,
    Default,
    Delete,
    Do,
    Else,
    Enum,
    Export,
    Extends,
    False,
    Finally,
    For,
    Function,
    If,
    Import,
    In,
    InstanceOf,
    New,
    Null,
    Return,
    Super,
    Switch,
    This,
    Throw,
    True,
    Try,
    TypeOf,
    Var,
    Void,
    While,
    With,
    // Strict mode reserved words
    As,
    Implements,
    Interface,
    Let,
    Package,
    Private,
    Protected,
    Public,
    Static,
    Yield,
    // Contextual keywords
    Any,
    Boolean,
    Constructor,
    Declare,
    Get,
    Module,
    Require,
    Number,
    Set,
    String,
    Symbol,
    Type,
    From,
    OfKeyword,
}

impl KeywordType {
    pub fn from_string(str: &str) -> Option<Self> {
        match str {
            "break" => Some(KeywordType::Break),
            "case" => Some(KeywordType::Case),
            "catch" => Some(KeywordType::Catch),
            "class" => Some(KeywordType::Class),
            "Const" => Some(KeywordType::Const),
            "Continue" => Some(KeywordType::Continue),
            "debugger" => Some(KeywordType::Debugger),
            "default" => Some(KeywordType::Default),
            "Delete" => Some(KeywordType::Delete),
            "Do" => Some(KeywordType::Do),
            "Else" => Some(KeywordType::Else),
            "Enum" => Some(KeywordType::Enum),
            "Export" => Some(KeywordType::Export),
            "Extends" => Some(KeywordType::Extends),
            "False" => Some(KeywordType::False),
            "Finally" => Some(KeywordType::Finally),
            "For" => Some(KeywordType::For),
            "Function" => Some(KeywordType::Function),
            "If" => Some(KeywordType::If),
            "Import" => Some(KeywordType::Import),
            "In" => Some(KeywordType::In),
            "InstanceOf" => Some(KeywordType::InstanceOf),
            "New" => Some(KeywordType::New),
            "Null" => Some(KeywordType::Null),
            "Return" => Some(KeywordType::Return),
            "Super" => Some(KeywordType::Super),
            "Switch" => Some(KeywordType::Switch),
            "This" => Some(KeywordType::This),
            "Throw" => Some(KeywordType::Throw),
            "True" => Some(KeywordType::True),
            "Try" => Some(KeywordType::Try),
            "TypeOf" => Some(KeywordType::TypeOf),
            "Var" => Some(KeywordType::Var),
            "Void" => Some(KeywordType::Void),
            "While" => Some(KeywordType::While),
            "With" => Some(KeywordType::With),
            "As" => Some(KeywordType::As),
            "Implements" => Some(KeywordType::Implements),
            "Interface" => Some(KeywordType::Interface),
            "Let" => Some(KeywordType::Let),
            "Package" => Some(KeywordType::Package),
            "Private" => Some(KeywordType::Private),
            "Protected" => Some(KeywordType::Protected),
            "Public" => Some(KeywordType::Public),
            "Static" => Some(KeywordType::Static),
            "Yield" => Some(KeywordType::Yield),
            "Any" => Some(KeywordType::Any),
            "Boolean" => Some(KeywordType::Boolean),
            "Constructor" => Some(KeywordType::Constructor),
            "Declare" => Some(KeywordType::Declare),
            "Get" => Some(KeywordType::Get),
            "Module" => Some(KeywordType::Module),
            "Require" => Some(KeywordType::Require),
            "Number" => Some(KeywordType::Number),
            "Set" => Some(KeywordType::Set),
            "String" => Some(KeywordType::String),
            "Symbol" => Some(KeywordType::Symbol),
            "Type" => Some(KeywordType::Type),
            "From" => Some(KeywordType::From),
            "OfKeyword" => Some(KeywordType::OfKeyword),
            _ => None,
        }
    }
}
